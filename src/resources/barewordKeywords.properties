__FILE__=
__LINE__=
__PACKAGE__=
__DATA__=
__END__=
CORE=
EQ=
GE=
GT=
LE=
LT=
NE=
NULL=
and=
cmp=
continue=       continue BLOCK\n       continue\n               "continue" is actually a flow control statement rather than a\n               function.  If there is a "continue" BLOCK attached to a BLOCK\n               (typically in a "while" or "foreach"), it is always executed\n               just before the conditional is about to be evaluated again,\n               just like the third part of a "for" loop in C.  Thus it can be\n               used to increment a loop variable, even when the loop has been\n               continued via the "next" statement (which is similar to the C\n               "continue" statement).
default=
do=       do BLOCK\n               Not really a function.  Returns the value of the last command\n               in the sequence of commands indicated by BLOCK.  When modified\n               by the "while" or "until" loop modifier, executes the BLOCK\n               once before testing the loop condition. (On other statements\n               the loop modifiers test the conditional first.)\n\n               "do BLOCK" does _n_o_t count as a loop, so the loop control\n               statements "next", "last", or "redo" cannot be used to leave or\n               restart the block.  See perlsyn for alternative strategies.
else=
elsif=
eq=
err=
exp=       exp EXPR\n       exp     Returns _e (the natural logarithm base) to the power of EXPR.\n               If EXPR is omitted, gives "exp($_)".
for=
foreach=
ge=
given=
gt=
if=
le=
lock=       lock THING\n               This function places an advisory lock on a shared variable, or\n               referenced object contained in _T_H_I_N_G until the lock goes out of\n               scope.
lt=
m=       m//     The match operator.  See "Regexp Quote-Like Operators" in\n               perlop.
ne=
no=       no MODULE VERSION LIST\n       no MODULE VERSION\n       no MODULE LIST\n       no MODULE\n       no VERSION\n               See the "use" function, of which "no" is the opposite.
or=
package=       package NAMESPACE VERSION\n       package NAMESPACE\n               Declares the compilation unit as being in the given namespace.\n               The scope of the package declaration is from the declaration\n               itself through the end of the enclosing block, file, or eval\n               (the same as the "my" operator).  All further unqualified\n               dynamic identifiers will be in this namespace.  A package\n               statement affects dynamic variables only, including those\n               you've used "local" on, but _n_o_t lexical variables, which are\n               created with "my" (or "our" (or "state")).  Typically it would\n               be the first declaration in a file included by "require" or\n               "use".  You can switch into a package in more than one place,\n               since this only determines which default symbol table the\n               compiler uses for the rest of that block.  You can refer to\n               identifiers in other packages than the current one by prefixing\n               the identifier with the package name and a double colon, as in\n               $SomePack::var or "ThatPack::INPUT_HANDLE".  If package name is\n               omitted, the "main" package as assumed.  That is, $::sail is\n               equivalent to $main::sail (as well as to "$main'sail", still\n               seen in ancient code, mostly from Perl 4).
q=       q/STRING/\n       qq/STRING/\n       qx/STRING/\n       qw/STRING/\n               Generalized quotes.  See "Quote-Like Operators" in perlop.
qq=       qq/STRING/\n       qx/STRING/\n       qw/STRING/\n               Generalized quotes.  See "Quote-Like Operators" in perlop.
qr=       qr/STRING/\n               Regexp-like quote.  See "Regexp Quote-Like Operators" in\n               perlop.
qw=       qw/STRING/\n               Generalized quotes.  See "Quote-Like Operators" in perlop.
qx=       qx/STRING/\n       qw/STRING/\n               Generalized quotes.  See "Quote-Like Operators" in perlop.
s=       s///    The substitution operator.  See "Regexp Quote-Like Operators"\n               in perlop.
sub=       sub NAME BLOCK\n       sub NAME (PROTO) BLOCK\n       sub NAME : ATTRS BLOCK\n       sub NAME (PROTO) : ATTRS BLOCK\n               This is subroutine definition, not a real function _p_e_r _s_e.\n               Without a BLOCK it's just a forward declaration.  Without a\n               NAME, it's an anonymous function declaration, and does actually\n               return a value: the CODE ref of the closure you just created.
tr=       tr///   The transliteration operator.  Same as "y///".  See "Quote and\n               Quote-like Operators" in perlop.
unless=
until=
when=
while=
x=
xor=
y=       y///    The transliteration operator.  Same as "tr///".  See "Quote and\n               Quote-like Operators" in perlop.
