__SUB__=
AUTOLOAD=
BEGIN=
DESTROY=
END=
INIT=
CHECK=
UNITCHECK=
abs=       abs VALUE\n       abs     Returns the absolute value of its argument.  If VALUE is\n               omitted, uses $_.
accept=       accept NEWSOCKET,GENERICSOCKET\n               Accepts an incoming socket connect, just as _a_c_c_e_p_t(2) does.\n               Returns the packed address if it succeeded, false otherwise.\n               See the example in "Sockets: Client/Server Communication" in\n               perlipc.
alarm=       alarm SECONDS\n       alarm   Arranges to have a SIGALRM delivered to this process after the\n               specified number of wallclock seconds has elapsed.  If SECONDS\n               is not specified, the value stored in $_ is used. (On some\n               machines, unfortunately, the elapsed time may be up to one\n               second less or more than you specified because of how seconds\n               are counted, and process scheduling may delay the delivery of\n               the signal even further.)\n\n               Only one timer may be counting at once.  Each call disables the\n               previous timer, and an argument of 0 may be supplied to cancel\n               the previous timer without starting a new one.  The returned\n               value is the amount of time remaining on the previous timer.
atan2=       atan2 Y,X\n               Returns the arctangent of Y/X in the range -PI to PI.
bind=       bind SOCKET,NAME\n               Binds a network address to a socket, just as _b_i_n_d(2) does.\n               Returns true if it succeeded, false otherwise.  NAME should be\n               a packed address of the appropriate type for the socket.  See\n               the examples in "Sockets: Client/Server Communication" in\n               perlipc.
binmode=       binmode FILEHANDLE, LAYER\n       binmode FILEHANDLE\n               Arranges for FILEHANDLE to be read or written in "binary" or\n               "text" mode on systems where the run-time libraries distinguish\n               between binary and text files.  If FILEHANDLE is an expression,\n               the value is taken as the name of the filehandle.  Returns true\n               on success, otherwise it returns "undef" and sets $! (errno).
bless=       bless REF,CLASSNAME\n       bless REF\n               This function tells the thingy referenced by REF that it is now\n               an object in the CLASSNAME package.  If CLASSNAME is omitted,\n               the current package is used.  Because a "bless" is often the\n               last thing in a constructor, it returns the reference for\n               convenience.  Always use the two-argument version if a derived\n               class might inherit the function doing the blessing.  See\n               perltoot and perlobj for more about the blessing (and\n               blessings) of objects.
break=       break   Break out of a "given()" block.
caller=       caller EXPR\n       caller  Returns the context of the current subroutine call.  In scalar\n               context, returns the caller's package name if there _i_s a caller\n               (that is, if we're in a subroutine or "eval" or "require") and\n               the undefined value otherwise.  In list context, returns\n\n                   # 0         1          2\n                   ($package, $filename, $line) = caller;\n\n               With EXPR, it returns some extra information that the debugger\n               uses to print a stack trace.  The value of EXPR indicates how\n               many call frames to go back before the current one.
chdir=       chdir EXPR\n       chdir FILEHANDLE\n       chdir DIRHANDLE\n       chdir   Changes the working directory to EXPR, if possible. If EXPR is\n               omitted, changes to the directory specified by $ENV{HOME}, if\n               set; if not, changes to the directory specified by\n               $ENV{LOGDIR}. (Under VMS, the variable $ENV{SYS$LOGIN} is also\n               checked, and used if it is set.) If neither is set, "chdir"\n               does nothing. It returns true on success, false otherwise. See\n               the example under "die".
chmod=       chmod LIST\n               Changes the permissions of a list of files.  The first element\n               of the list must be the numerical mode, which should probably\n               be an octal number, and which definitely should _n_o_t be a string\n               of octal digits: 0644 is okay, but "0644" is not.  Returns the\n               number of files successfully changed.  See also "oct", if all\n               you have is a string.
chomp=       chomp VARIABLE\n       chomp( LIST )\n       chomp   This safer version of "chop" removes any trailing string that\n               corresponds to the current value of $/ (also known as\n               $INPUT_RECORD_SEPARATOR in the "English" module).  It returns\n               the total number of characters removed from all its arguments.\n               It's often used to remove the newline from the end of an input\n               record when you're worried that the final record may be missing\n               its newline.  When in paragraph mode ("$/ = """), it removes\n               all trailing newlines from the string.  When in slurp mode ("$/\n               = undef") or fixed-length record mode ($/ is a reference to an\n               integer or the like, see perlvar) _c_h_o_m_p_(_) won't remove\n               anything.  If VARIABLE is omitted, it chomps $_.  Example:\n\n                   while (<>) {\n                       chomp;  # avoid \\n on last field\n                       @array = split(/:/);\n                       # ...\n                   }\n\n               If VARIABLE is a hash, it chomps the hash's values, but not its\n               keys.
chop=       chop VARIABLE\n       chop( LIST )\n       chop    Chops off the last character of a string and returns the\n               character chopped.  It is much more efficient than "s/.$//s"\n               because it neither scans nor copies the string.  If VARIABLE is\n               omitted, chops $_.  If VARIABLE is a hash, it chops the hash's\n               values, but not its keys.
chown=       chown LIST\n               Changes the owner (and group) of a list of files.  The first\n               two elements of the list must be the _n_u_m_e_r_i_c uid and gid, in\n               that order.  A value of -1 in either position is interpreted by\n               most systems to leave that value unchanged.  Returns the number\n               of files successfully changed.
chr=       chr NUMBER\n       chr     Returns the character represented by that NUMBER in the\n               character set.  For example, "chr(65)" is "A" in either ASCII\n               or Unicode, and chr(0x263a) is a Unicode smiley face.
chroot=       chroot FILENAME\n       chroot  This function works like the system call by the same name: it\n               makes the named directory the new root directory for all\n               further pathnames that begin with a "/" by your process and all\n               its children.  (It doesn't change your current working\n               directory, which is unaffected.)  For security reasons, this\n               call is restricted to the superuser.  If FILENAME is omitted,\n               does a "chroot" to $_.
close=       close FILEHANDLE\n       close   Closes the file or pipe associated with the filehandle, flushes\n               the IO buffers, and closes the system file descriptor.  Returns\n               true if those operations have succeeded and if no error was\n               reported by any PerlIO layer.  Closes the currently selected\n               filehandle if the argument is omitted.
closedir=       closedir DIRHANDLE\n               Closes a directory opened by "opendir" and returns the success\n               of that system call.
connect=       connect SOCKET,NAME\n               Attempts to connect to a remote socket, just like _c_o_n_n_e_c_t(2).\n               Returns true if it succeeded, false otherwise.  NAME should be\n               a packed address of the appropriate type for the socket.  See\n               the examples in "Sockets: Client/Server Communication" in\n               perlipc.
cos=       cos EXPR\n       cos     Returns the cosine of EXPR (expressed in radians).  If EXPR is\n               omitted, takes cosine of $_.
crypt=       crypt PLAINTEXT,SALT\n               Creates a digest string exactly like the _c_r_y_p_t(3) function in\n               the C library (assuming that you actually have a version there\n               that has not been extirpated as a potential munition).
dbmclose=       dbmclose HASH\n               [This function has been largely superseded by the "untie"\n               function.]\n\n               Breaks the binding between a DBM file and a hash.
dbmopen=       dbmopen HASH,DBNAME,MASK\n               [This function has been largely superseded by the "tie"\n               function.]\n\n               This binds a _d_b_m(3), _n_d_b_m(3), _s_d_b_m(3), _g_d_b_m(3), or Berkeley DB\n               file to a hash.  HASH is the name of the hash.  (Unlike normal\n               "open", the first argument is _n_o_t a filehandle, even though it\n               looks like one).  DBNAME is the name of the database (without\n               the _._d_i_r or _._p_a_g extension if any).  If the database does not\n               exist, it is created with protection specified by MASK (as\n               modified by the "umask").  If your system supports only the\n               older DBM functions, you may make only one "dbmopen" call in\n               your program.  In older versions of Perl, if your system had\n               neither DBM nor ndbm, calling "dbmopen" produced a fatal error;\n               it now falls back to _s_d_b_m(3).
defined=       defined EXPR\n       defined Returns a Boolean value telling whether EXPR has a value other\n               than the undefined value "undef".  If EXPR is not present, $_\n               is checked.
delete=       delete EXPR\n               Given an expression that specifies an element or slice of a\n               hash, "delete" deletes the specified elements from that hash so\n               that _e_x_i_s_t_s_(_) on that element no longer returns true.  Setting\n               a hash element to the undefined value does not remove its key,\n               but deleting it does; see "exists".
die=       die LIST\n               "die" raises an exception. Inside an "eval" the error message\n               is stuffed into $@ and the "eval" is terminated with the\n               undefined value.  If the exception is outside of all enclosing\n               "eval"s, then the uncaught exception prints LIST to "STDERR"\n               and exits with a non-zero value. If you need to exit the\n               process with a specific exit code, see exit.
dump=       dump LABEL\n       dump    This function causes an immediate core dump.  See also the --uu\n               command-line switch in perlrun, which does the same thing.\n               Primarily this is so that you can use the uunndduummpp program (not\n               supplied) to turn your core dump into an executable binary\n               after having initialized all your variables at the beginning of\n               the program.  When the new binary is executed it will begin by\n               executing a "goto LABEL" (with all the restrictions that "goto"\n               suffers).  Think of it as a goto with an intervening core dump\n               and reincarnation.  If "LABEL" is omitted, restarts the program\n               from the top.
each=       each HASH\n       each ARRAY\n               When called in list context, returns a 2-element list\n               consisting of the key and value for the next element of a hash,\n               or the index and value for the next element of an array, so\n               that you can iterate over it.  When called in scalar context,\n               returns only the key (not the value) in a hash, or the index in\n               an array.
endgrent=       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
endhostent=       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
endnetent=       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
endprotoent=       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
endpwent=       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
endservent=       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
eof=       eof FILEHANDLE\n       eof ()\n       eof     Returns 1 if the next read on FILEHANDLE will return end of\n               file, or if FILEHANDLE is not open.  FILEHANDLE may be an\n               expression whose value gives the real filehandle.  (Note that\n               this function actually reads a character and then "ungetc"s it,\n               so isn't useful in an interactive context.)  Do not read from a\n               terminal file (or call "eof(FILEHANDLE)" on it) after end-of-\n               file is reached.  File types such as terminals may lose the\n               end-of-file condition if you do.
eval=       eval EXPR\n       eval BLOCK\n       eval    In the first form, the return value of EXPR is parsed and\n               executed as if it were a little Perl program.  The value of the\n               expression (which is itself determined within scalar context)\n               is first parsed, and if there weren't any errors, executed in\n               the lexical context of the current Perl program, so that any\n               variable settings or subroutine and format definitions remain\n               afterwards.  Note that the value is parsed every time the\n               "eval" executes.  If EXPR is omitted, evaluates $_.  This form\n               is typically used to delay parsing and subsequent execution of\n               the text of EXPR until run time.
evalbytes=
exec=       exec LIST\n       exec PROGRAM LIST\n               The "exec" function executes a system command _a_n_d _n_e_v_e_r\n               _r_e_t_u_r_n_s; use "system" instead of "exec" if you want it to\n               return.  It fails and returns false only if the command does\n               not exist _a_n_d it is executed directly instead of via your\n               system's command shell (see below).
exists=       exists EXPR\n               Given an expression that specifies an element of a hash,\n               returns true if the specified element in the hash has ever been\n               initialized, even if the corresponding value is undefined.
exit=       exit EXPR\n       exit    Evaluates EXPR and exits immediately with that value.\n               Example:\n\n                   $ans = <STDIN>;\n                   exit 0 if $ans =~ /^[Xx]/;\n\n               See also "die".  If EXPR is omitted, exits with 0 status.  The\n               only universally recognized values for EXPR are 0 for success\n               and 1 for error; other values are subject to interpretation\n               depending on the environment in which the Perl program is\n               running.  For example, exiting 69 (EX_UNAVAILABLE) from a\n               _s_e_n_d_m_a_i_l incoming-mail filter will cause the mailer to return\n               the item undelivered, but that's not true everywhere.
fc=
fcntl=       fcntl FILEHANDLE,FUNCTION,SCALAR\n               Implements the _f_c_n_t_l(2) function.  You'll probably have to say\n\n                   use Fcntl;\n\n               first to get the correct constant definitions.  Argument\n               processing and value returned work just like "ioctl" below.\n               For example:\n\n                   use Fcntl;\n                   fcntl($filehandle, F_GETFL, $packed_return_buffer)\n                       or die "can't fcntl F_GETFL: $!";\n\n               You don't have to check for "defined" on the return from\n               "fcntl".  Like "ioctl", it maps a 0 return from the system call\n               into "0 but true" in Perl.  This string is true in boolean\n               context and 0 in numeric context.  It is also exempt from the\n               normal --ww warnings on improper numeric conversions.
fileno=       fileno FILEHANDLE\n               Returns the file descriptor for a filehandle, or undefined if\n               the filehandle is not open.  This is mainly useful for\n               constructing bitmaps for "select" and low-level POSIX tty-\n               handling operations.  If FILEHANDLE is an expression, the value\n               is taken as an indirect filehandle, generally its name.
flock=       flock FILEHANDLE,OPERATION\n               Calls _f_l_o_c_k(2), or an emulation of it, on FILEHANDLE.  Returns\n               true for success, false on failure.  Produces a fatal error if\n               used on a machine that doesn't implement _f_l_o_c_k(2), _f_c_n_t_l(2)\n               locking, or _l_o_c_k_f(3).  "flock" is Perl's portable file locking\n               interface, although it locks entire files only, not records.
fork=       fork    Does a _f_o_r_k(2) system call to create a new process running the\n               same program at the same point.  It returns the child pid to\n               the parent process, 0 to the child process, or "undef" if the\n               fork is unsuccessful.  File descriptors (and sometimes locks on\n               those descriptors) are shared, while everything else is copied.\n               On most systems supporting _f_o_r_k_(_), great care has gone into\n               making it extremely efficient (for example, using copy-on-write\n               technology on data pages), making it the dominant paradigm for\n               multitasking over the last few decades.
format=       format  Declare a picture format for use by the "write" function.  For\n               example:\n\n                   format Something =\n                       Test: @<<<<<<<< @||||| @>>>>>\n                             $str,     $%,    '$' . int($num)\n                   .
formline=       formline PICTURE,LIST\n               This is an internal function used by "format"s, though you may\n               call it, too.  It formats (see perlform) a list of values\n               according to the contents of PICTURE, placing the output into\n               the format output accumulator, $^A (or $ACCUMULATOR in\n               English).  Eventually, when a "write" is done, the contents of\n               $^A are written to some filehandle.  You could also read $^A\n               and then set $^A back to "".  Note that a format typically does\n               one "formline" per line of form, but the "formline" function\n               itself doesn't care how many newlines are embedded in the\n               PICTURE.  This means that the "~" and "~~" tokens treat the\n               entire PICTURE as a single line.  You may therefore need to use\n               multiple formlines to implement a single record format, just\n               like the "format" compiler.
getc=       getc FILEHANDLE\n       getc    Returns the next character from the input file attached to\n               FILEHANDLE, or the undefined value at end of file or if there\n               was an error (in the latter case $! is set).  If FILEHANDLE is\n               omitted, reads from STDIN.  This is not particularly efficient.\n               However, it cannot be used by itself to fetch single characters\n               without waiting for the user to hit enter.  For that, try\n               something more like:\n\n                   if ($BSD_STYLE) {\n                       system "stty cbreak </dev/tty >/dev/tty 2>&1";\n                   }\n                   else {\n                       system "stty", '-icanon', 'eol', "\\001";\n                   }\n\n                   $key = getc(STDIN);\n\n                   if ($BSD_STYLE) {\n                       system "stty -cbreak </dev/tty >/dev/tty 2>&1";\n                   }\n                   else {\n                       system 'stty', 'icanon', 'eol', '^@'; # ASCII NUL\n                   }\n                   print "\\n";\n\n               Determination of whether $BSD_STYLE should be set is left as an\n               exercise to the reader.
getgrent=       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getgrgid=       getgrgid GID\n       getservbyname NAME,PROTO\n       gethostbyaddr ADDR,ADDRTYPE\n       getnetbyaddr ADDR,ADDRTYPE\n       getprotobynumber NUMBER\n       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getgrnam=       getgrnam NAME\n       gethostbyname NAME\n       getnetbyname NAME\n       getprotobyname NAME\n       getpwuid UID\n       getgrgid GID\n       getservbyname NAME,PROTO\n       gethostbyaddr ADDR,ADDRTYPE\n       getnetbyaddr ADDR,ADDRTYPE\n       getprotobynumber NUMBER\n       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
gethostbyaddr=       gethostbyaddr ADDR,ADDRTYPE\n       getnetbyaddr ADDR,ADDRTYPE\n       getprotobynumber NUMBER\n       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
gethostbyname=       gethostbyname NAME\n       getnetbyname NAME\n       getprotobyname NAME\n       getpwuid UID\n       getgrgid GID\n       getservbyname NAME,PROTO\n       gethostbyaddr ADDR,ADDRTYPE\n       getnetbyaddr ADDR,ADDRTYPE\n       getprotobynumber NUMBER\n       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
gethostent=       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getlogin=       getlogin\n               This implements the C library function of the same name, which\n               on most systems returns the current login from _/_e_t_c_/_u_t_m_p, if\n               any.  If it returns the empty string, use "getpwuid".
getnetbyaddr=       getnetbyaddr ADDR,ADDRTYPE\n       getprotobynumber NUMBER\n       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getnetbyname=       getnetbyname NAME\n       getprotobyname NAME\n       getpwuid UID\n       getgrgid GID\n       getservbyname NAME,PROTO\n       gethostbyaddr ADDR,ADDRTYPE\n       getnetbyaddr ADDR,ADDRTYPE\n       getprotobynumber NUMBER\n       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getnetent=       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getpeername=       getpeername SOCKET\n               Returns the packed sockaddr address of other end of the SOCKET\n               connection.
getpgrp=       getpgrp PID\n               Returns the current process group for the specified PID.  Use a\n               PID of 0 to get the current process group for the current\n               process.  Will raise an exception if used on a machine that\n               doesn't implement _g_e_t_p_g_r_p(2).  If PID is omitted, returns\n               process group of current process.  Note that the POSIX version\n               of "getpgrp" does not accept a PID argument, so only "PID==0"\n               is truly portable.
getppid=       getppid Returns the process id of the parent process.
getpriority=       getpriority WHICH,WHO\n               Returns the current priority for a process, a process group, or\n               a user.  (See getpriority(2).)  Will raise a fatal exception if\n               used on a machine that doesn't implement _g_e_t_p_r_i_o_r_i_t_y(2).
getprotobyname=       getprotobyname NAME\n       getpwuid UID\n       getgrgid GID\n       getservbyname NAME,PROTO\n       gethostbyaddr ADDR,ADDRTYPE\n       getnetbyaddr ADDR,ADDRTYPE\n       getprotobynumber NUMBER\n       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getprotobynumber=       getprotobynumber NUMBER\n       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getprotoent=       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getpwent=       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getpwnam=       getpwnam NAME\n       getgrnam NAME\n       gethostbyname NAME\n       getnetbyname NAME\n       getprotobyname NAME\n       getpwuid UID\n       getgrgid GID\n       getservbyname NAME,PROTO\n       gethostbyaddr ADDR,ADDRTYPE\n       getnetbyaddr ADDR,ADDRTYPE\n       getprotobynumber NUMBER\n       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getpwuid=       getpwuid UID\n       getgrgid GID\n       getservbyname NAME,PROTO\n       gethostbyaddr ADDR,ADDRTYPE\n       getnetbyaddr ADDR,ADDRTYPE\n       getprotobynumber NUMBER\n       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getservbyname=       getservbyname NAME,PROTO\n       gethostbyaddr ADDR,ADDRTYPE\n       getnetbyaddr ADDR,ADDRTYPE\n       getprotobynumber NUMBER\n       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getservbyport=       getservbyport PORT,PROTO\n       getpwent\n       getgrent\n       gethostent\n       getnetent\n       getprotoent\n       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getservent=       getservent\n       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
getsockname=       getsockname SOCKET\n               Returns the packed sockaddr address of this end of the SOCKET\n               connection, in case you don't know the address because you have\n               several different IPs that the connection might have come in\n               on.
getsockopt=       getsockopt SOCKET,LEVEL,OPTNAME\n               Queries the option named OPTNAME associated with SOCKET at a\n               given LEVEL.  Options may exist at multiple protocol levels\n               depending on the socket type, but at least the uppermost socket\n               level SOL_SOCKET (defined in the "Socket" module) will exist.\n               To query options at another level the protocol number of the\n               appropriate protocol controlling the option should be supplied.\n               For example, to indicate that an option is to be interpreted by\n               the TCP protocol, LEVEL should be set to the protocol number of\n               TCP, which you can get using "getprotobyname".
glob=       glob EXPR\n       glob    In list context, returns a (possibly empty) list of filename\n               expansions on the value of EXPR such as the standard Unix shell\n               _/_b_i_n_/_c_s_h would do. In scalar context, glob iterates through\n               such filename expansions, returning undef when the list is\n               exhausted. This is the internal function implementing the\n               "<*.c>" operator, but you can use it directly. If EXPR is\n               omitted, $_ is used.  The "<*.c>" operator is discussed in more\n               detail in "I/O Operators" in perlop.
gmtime=       gmtime EXPR\n       gmtime  Works just like localtime but the returned values are localized\n               for the standard Greenwich time zone.
goto=       goto LABEL\n       goto EXPR\n       goto &NAME\n               The "goto-LABEL" form finds the statement labeled with LABEL\n               and resumes execution there. It can't be used to get out of a\n               block or subroutine given to "sort".  It can be used to go\n               almost anywhere else within the dynamic scope, including out of\n               subroutines, but it's usually better to use some other\n               construct such as "last" or "die".  The author of Perl has\n               never felt the need to use this form of "goto" (in Perl, that\n               is; C is another matter).  (The difference is that C does not\n               offer named loops combined with loop control.  Perl does, and\n               this replaces most structured uses of "goto" in other\n               languages.)\n\n               The "goto-EXPR" form expects a label name, whose scope will be\n               resolved dynamically.  This allows for computed "goto"s per\n               FORTRAN, but isn't necessarily recommended if you're optimizing\n               for maintainability:\n\n                   goto ("FOO", "BAR", "GLARCH")[$i];\n\n               Use of "goto-LABEL" or "goto-EXPR" to jump into a construct is\n               deprecated and will issue a warning.  Even then, it may not be\n               used to go into any construct that requires initialization,\n               such as a subroutine or a "foreach" loop.  It also can't be\n               used to go into a construct that is optimized away.
grep=       grep BLOCK LIST\n       grep EXPR,LIST\n               This is similar in spirit to, but not the same as, _g_r_e_p(1) and\n               its relatives.  In particular, it is not limited to using\n               regular expressions.
hex=       hex EXPR\n       hex     Interprets EXPR as a hex string and returns the corresponding\n               value.  (To convert strings that might start with either 0,\n               "0x", or "0b", see "oct".)  If EXPR is omitted, uses $_.
index=       index STR,SUBSTR,POSITION\n       index STR,SUBSTR\n               The index function searches for one string within another, but\n               without the wildcard-like behavior of a full regular-expression\n               pattern match.  It returns the position of the first occurrence\n               of SUBSTR in STR at or after POSITION.  If POSITION is omitted,\n               starts searching from the beginning of the string.  POSITION\n               before the beginning of the string or after its end is treated\n               as if it were the beginning or the end, respectively.  POSITION\n               and the return value are based at 0 (or whatever you've set the\n               $[ variable to--but don't do that).  If the substring is not\n               found, "index" returns one less than the base, ordinarily "-1".
int=       int EXPR\n       int     Returns the integer portion of EXPR.  If EXPR is omitted, uses\n               $_.  You should not use this function for rounding: one because\n               it truncates towards 0, and two because machine representations\n               of floating-point numbers can sometimes produce\n               counterintuitive results.  For example, "int(-6.725/0.025)"\n               produces -268 rather than the correct -269; that's because it's\n               really more like -268.99999999999994315658 instead.  Usually,\n               the "sprintf", "printf", or the "POSIX::floor" and\n               "POSIX::ceil" functions will serve you better than will _i_n_t_(_).
ioctl=       ioctl FILEHANDLE,FUNCTION,SCALAR\n               Implements the _i_o_c_t_l(2) function.  You'll probably first have\n               to say\n\n                   require "sys/ioctl.ph";  # probably in $Config{archlib}/sys/ioctl.ph\n\n               to get the correct function definitions.  If _s_y_s_/_i_o_c_t_l_._p_h\n               doesn't exist or doesn't have the correct definitions you'll\n               have to roll your own, based on your C header files such as\n               _<_s_y_s_/_i_o_c_t_l_._h_>.  (There is a Perl script called hh22pphh that comes\n               with the Perl kit that may help you in this, but it's\n               nontrivial.)  SCALAR will be read and/or written depending on\n               the FUNCTION; a C pointer to the string value of SCALAR will be\n               passed as the third argument of the actual "ioctl" call.  (If\n               SCALAR has no string value but does have a numeric value, that\n               value will be passed rather than a pointer to the string value.\n               To guarantee this to be true, add a 0 to the scalar before\n               using it.)  The "pack" and "unpack" functions may be needed to\n               manipulate the values of structures used by "ioctl".
join=       join EXPR,LIST\n               Joins the separate strings of LIST into a single string with\n               fields separated by the value of EXPR, and returns that new\n               string.  Example:\n\n                   $rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);\n\n               Beware that unlike "split", "join" doesn't take a pattern as\n               its first argument.  Compare "split".
keys=       keys HASH\n       keys ARRAY\n               Returns a list consisting of all the keys of the named hash, or\n               the indices of an array. (In scalar context, returns the number\n               of keys or indices.)\n\n               The keys of a hash are returned in an apparently random order.\n               The actual random order is subject to change in future versions\n               of Perl, but it is guaranteed to be the same order as either\n               the "values" or "each" function produces (given that the hash\n               has not been modified).  Since Perl 5.8.1 the ordering is\n               different even between different runs of Perl for security\n               reasons (see "Algorithmic Complexity Attacks" in perlsec).
kill=       kill SIGNAL, LIST\n               Sends a signal to a list of processes.  Returns the number of\n               processes successfully signaled (which is not necessarily the\n               same as the number actually killed).
last=       last LABEL\n       last    The "last" command is like the "break" statement in C (as used\n               in loops); it immediately exits the loop in question.  If the\n               LABEL is omitted, the command refers to the innermost enclosing\n               loop.  The "continue" block, if any, is not executed:\n\n                   LINE: while (<STDIN>) {\n                       last LINE if /^$/;  # exit when done with header\n                       #...\n                   }\n\n               "last" cannot be used to exit a block that returns a value such\n               as "eval {}", "sub {}" or "do {}", and should not be used to\n               exit a _g_r_e_p_(_) or _m_a_p_(_) operation.
lc=       lc EXPR\n       lc      Returns a lowercased version of EXPR.  This is the internal\n               function implementing the "\\L" escape in double-quoted strings.
lcfirst=       lcfirst EXPR\n       lcfirst Returns the value of EXPR with the first character lowercased.\n               This is the internal function implementing the "\\l" escape in\n               double-quoted strings.
length=       length EXPR\n       length  Returns the length in _c_h_a_r_a_c_t_e_r_s of the value of EXPR.  If EXPR\n               is omitted, returns length of $_.  If EXPR is undefined,\n               returns "undef".
link=       link OLDFILE,NEWFILE\n               Creates a new filename linked to the old filename.  Returns\n               true for success, false otherwise.
listen=       listen SOCKET,QUEUESIZE\n               Does the same thing that the _l_i_s_t_e_n(2) system call does.\n               Returns true if it succeeded, false otherwise.  See the example\n               in "Sockets: Client/Server Communication" in perlipc.
local=       local EXPR\n               You really probably want to be using "my" instead, because\n               "local" isn't what most people think of as "local".  See\n               "Private Variables via _m_y_(_)" in perlsub for details.
localtime=       localtime EXPR\n       localtime\n               Converts a time as returned by the time function to a 9-element\n               list with the time analyzed for the local time zone.  Typically\n               used as follows:\n\n                   #  0    1    2     3     4    5     6     7     8\n                   ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =\n                                                               localtime(time);\n\n               All list elements are numeric, and come straight out of the C\n               `struct tm'.  $sec, $min, and $hour are the seconds, minutes,\n               and hours of the specified time.
log=       log EXPR\n       log     Returns the natural logarithm (base _e) of EXPR.  If EXPR is\n               omitted, returns log of $_.  To get the log of another base,\n               use basic algebra: The base-N log of a number is equal to the\n               natural log of that number divided by the natural log of N.\n               For example:\n\n                   sub log10 {\n                       my $n = shift;\n                       return log($n)/log(10);\n                   }\n\n               See also "exp" for the inverse operation.
lstat=       lstat EXPR\n       lstat   Does the same thing as the "stat" function (including setting\n               the special "_" filehandle) but stats a symbolic link instead\n               of the file the symbolic link points to.  If symbolic links are\n               unimplemented on your system, a normal "stat" is done.  For\n               much more detailed information, please see the documentation\n               for "stat".
map=       map BLOCK LIST\n       map EXPR,LIST\n               Evaluates the BLOCK or EXPR for each element of LIST (locally\n               setting $_ to each element) and returns the list value composed\n               of the results of each such evaluation.  In scalar context,\n               returns the total number of elements so generated.  Evaluates\n               BLOCK or EXPR in list context, so each element of LIST may\n               produce zero, one, or more elements in the returned value.
mkdir=       mkdir FILENAME,MASK\n       mkdir FILENAME\n       mkdir   Creates the directory specified by FILENAME, with permissions\n               specified by MASK (as modified by "umask").  If it succeeds it\n               returns true, otherwise it returns false and sets $! (errno).\n               If omitted, MASK defaults to 0777. If omitted, FILENAME\n               defaults to $_.
msgctl=       msgctl ID,CMD,ARG\n               Calls the System V IPC function _m_s_g_c_t_l(2).  You'll probably\n               have to say\n\n                   use IPC::SysV;\n\n               first to get the correct constant definitions.  If CMD is\n               "IPC_STAT", then ARG must be a variable that will hold the\n               returned "msqid_ds" structure.  Returns like "ioctl": the\n               undefined value for error, "0 but true" for zero, or the actual\n               return value otherwise.  See also "SysV IPC" in perlipc,\n               "IPC::SysV", and "IPC::Semaphore" documentation.
msgget=       msgget KEY,FLAGS\n               Calls the System V IPC function _m_s_g_g_e_t(2).  Returns the message\n               queue id, or the undefined value if there is an error.  See\n               also "SysV IPC" in perlipc and "IPC::SysV" and "IPC::Msg"\n               documentation.
msgrcv=       msgrcv ID,VAR,SIZE,TYPE,FLAGS\n               Calls the System V IPC function msgrcv to receive a message\n               from message queue ID into variable VAR with a maximum message\n               size of SIZE.  Note that when a message is received, the\n               message type as a native long integer will be the first thing\n               in VAR, followed by the actual message.  This packing may be\n               opened with "unpack("l! a*")".  Taints the variable.  Returns\n               true if successful, or false if there is an error.  See also\n               "SysV IPC" in perlipc, "IPC::SysV", and "IPC::SysV::Msg"\n               documentation.
msgsnd=       msgsnd ID,MSG,FLAGS\n               Calls the System V IPC function msgsnd to send the message MSG\n               to the message queue ID.  MSG must begin with the native long\n               integer message type, and be followed by the length of the\n               actual message, and finally the message itself.  This kind of\n               packing can be achieved with "pack("l! a*", $type, $message)".\n               Returns true if successful, or false if there is an error.  See\n               also "IPC::SysV" and "IPC::SysV::Msg" documentation.
my=       my EXPR\n       my TYPE EXPR\n       my EXPR : ATTRS\n       my TYPE EXPR : ATTRS\n               A "my" declares the listed variables to be local (lexically) to\n               the enclosing block, file, or "eval".  If more than one value\n               is listed, the list must be placed in parentheses.
next=       next LABEL\n       next    The "next" command is like the "continue" statement in C; it\n               starts the next iteration of the loop:\n\n                   LINE: while (<STDIN>) {\n                       next LINE if /^#/;  # discard comments\n                       #...\n                   }\n\n               Note that if there were a "continue" block on the above, it\n               would get executed even on discarded lines.  If LABEL is\n               omitted, the command refers to the innermost enclosing loop.
not=
oct=       oct EXPR\n       oct     Interprets EXPR as an octal string and returns the\n               corresponding value.  (If EXPR happens to start off with "0x",\n               interprets it as a hex string.  If EXPR starts off with "0b",\n               it is interpreted as a binary string.  Leading whitespace is\n               ignored in all three cases.)  The following will handle\n               decimal, binary, octal, and hex in standard Perl notation:\n\n                   $val = oct($val) if $val =~ /^0/;\n\n               If EXPR is omitted, uses $_.   To go the other way (produce a\n               number in octal), use _s_p_r_i_n_t_f_(_) or _p_r_i_n_t_f_(_):\n\n                   $dec_perms = (stat("filename"))[2] & 07777;\n                   $oct_perm_str = sprintf "%o", $perms;\n\n               The _o_c_t_(_) function is commonly used when a string such as 644\n               needs to be converted into a file mode, for example.  Although\n               Perl automatically converts strings into numbers as needed,\n               this automatic conversion assumes base 10.
open=       open FILEHANDLE,EXPR\n       open FILEHANDLE,MODE,EXPR\n       open FILEHANDLE,MODE,EXPR,LIST\n       open FILEHANDLE,MODE,REFERENCE\n       open FILEHANDLE\n               Opens the file whose filename is given by EXPR, and associates\n               it with FILEHANDLE.
opendir=       opendir DIRHANDLE,EXPR\n               Opens a directory named EXPR for processing by "readdir",\n               "telldir", "seekdir", "rewinddir", and "closedir".  Returns\n               true if successful.  DIRHANDLE may be an expression whose value\n               can be used as an indirect dirhandle, usually the real\n               dirhandle name.  If DIRHANDLE is an undefined scalar variable\n               (or array or hash element), the variable is assigned a\n               reference to a new anonymous dirhandle.  DIRHANDLEs have their\n               own namespace separate from FILEHANDLEs.
ord=       ord EXPR\n       ord     Returns the numeric (the native 8-bit encoding, like ASCII or\n               EBCDIC, or Unicode) value of the first character of EXPR.  If\n               EXPR is omitted, uses $_.
our=       our EXPR\n       our TYPE EXPR\n       our EXPR : ATTRS\n       our TYPE EXPR : ATTRS\n               "our" associates a simple name with a package variable in the\n               current package for use within the current scope.  When "use\n               strict 'vars'" is in effect, "our" lets you use declared global\n               variables without qualifying them with package names, within\n               the lexical scope of the "our" declaration.  In this way "our"\n               differs from "use vars", which is package scoped.
pack=       pack TEMPLATE,LIST\n               Takes a LIST of values and converts it into a string using the\n               rules given by the TEMPLATE.  The resulting string is the\n               concatenation of the converted values.  Typically, each\n               converted value looks like its machine-level representation.\n               For example, on 32-bit machines an integer may be represented\n               by a sequence of 4 bytes, which  will in Perl be presented as a\n               string that's 4 characters long.
pipe=       pipe READHANDLE,WRITEHANDLE\n               Opens a pair of connected pipes like the corresponding system\n               call.  Note that if you set up a loop of piped processes,\n               deadlock can occur unless you are very careful.  In addition,\n               note that Perl's pipes use IO buffering, so you may need to set\n               $| to flush your WRITEHANDLE after each command, depending on\n               the application.
pop=       pop ARRAY\n       pop     Pops and returns the last value of the array, shortening the\n               array by one element.
pos=       pos SCALAR\n       pos     Returns the offset of where the last "m//g" search left off for\n               the variable in question ($_ is used when the variable is not\n               specified).  Note that 0 is a valid match offset.  "undef"\n               indicates that the search position is reset (usually due to\n               match failure, but can also be because no match has yet been\n               run on the scalar). "pos" directly accesses the location used\n               by the regexp engine to store the offset, so assigning to "pos"\n               will change that offset, and so will also influence the "\\G"\n               zero-width assertion in regular expressions. Because a failed\n               "m//gc" match doesn't reset the offset, the return from "pos"\n               won't change either in this case.  See perlre and perlop.
print=       print FILEHANDLE LIST\n       print LIST\n       print   Prints a string or a list of strings.  Returns true if\n               successful.  FILEHANDLE may be a scalar variable containing the\n               name of or a reference to the filehandle, thus introducing one\n               level of indirection.  (NOTE: If FILEHANDLE is a variable and\n               the next token is a term, it may be misinterpreted as an\n               operator unless you interpose a "+" or put parentheses around\n               the arguments.)  If FILEHANDLE is omitted, prints to standard\n               output by default, or to the last selected output channel; see\n               "select".  If LIST is also omitted, prints $_ to the currently\n               selected output handle.  To set the default output handle to\n               something other than STDOUT use the select operation.  The\n               current value of $, (if any) is printed between each LIST item.\n               The current value of "$\\" (if any) is printed after the entire\n               LIST has been printed.  Because print takes a LIST, anything in\n               the LIST is evaluated in list context, and any subroutine that\n               you call will have one or more of its expressions evaluated in\n               list context.  Also be careful not to follow the print keyword\n               with a left parenthesis unless you want the corresponding right\n               parenthesis to terminate the arguments to the print; put\n               parentheses around all the arguments (or interpose a "+", but\n               that doesn't look as good).
printf=       printf FILEHANDLE FORMAT, LIST\n       printf FORMAT, LIST\n               Equivalent to "print FILEHANDLE sprintf(FORMAT, LIST)", except\n               that "$\\" (the output record separator) is not appended.  The\n               first argument of the list will be interpreted as the "printf"\n               format. See "sprintf" for an explanation of the format\n               argument.  If "use locale" is in effect, and _P_O_S_I_X_:_:_s_e_t_l_o_c_a_l_e_(_)\n               has been called, the character used for the decimal separator\n               in formatted floating-point numbers is affected by the\n               LC_NUMERIC locale.  See perllocale and POSIX.
prototype=       prototype FUNCTION\n               Returns the prototype of a function as a string (or "undef" if\n               the function has no prototype).  FUNCTION is a reference to, or\n               the name of, the function whose prototype you want to retrieve.
push=       push ARRAY,LIST\n               Treats ARRAY as a stack, and pushes the values of LIST onto the\n               end of ARRAY.  The length of ARRAY increases by the length of\n               LIST.  Has the same effect as\n\n                   for $value (LIST) {\n                       $ARRAY[++$#ARRAY] = $value;\n                   }\n\n               but is more efficient.  Returns the number of elements in the\n               array following the completed "push".
quotemeta=       quotemeta EXPR\n       quotemeta\n               Returns the value of EXPR with all non-"word" characters\n               backslashed.  (That is, all characters not matching\n               "/[A-Za-z_0-9]/" will be preceded by a backslash in the\n               returned string, regardless of any locale settings.)  This is\n               the internal function implementing the "\\Q" escape in double-\n               quoted strings.
rand=       rand EXPR\n       rand    Returns a random fractional number greater than or equal to 0\n               and less than the value of EXPR.  (EXPR should be positive.)\n               If EXPR is omitted, the value 1 is used.  Currently EXPR with\n               the value 0 is also special-cased as 1 (this was undocumented\n               before Perl 5.8.0 and is subject to change in future versions\n               of Perl).  Automatically calls "srand" unless "srand" has\n               already been called.  See also "srand".
read=       read FILEHANDLE,SCALAR,LENGTH,OFFSET\n       read FILEHANDLE,SCALAR,LENGTH\n               Attempts to read LENGTH _c_h_a_r_a_c_t_e_r_s of data into variable SCALAR\n               from the specified FILEHANDLE.  Returns the number of\n               characters actually read, 0 at end of file, or undef if there\n               was an error (in the latter case $! is also set).  SCALAR will\n               be grown or shrunk so that the last character actually read is\n               the last character of the scalar after the read.
readdir=       readdir DIRHANDLE\n               Returns the next directory entry for a directory opened by\n               "opendir".  If used in list context, returns all the rest of\n               the entries in the directory.  If there are no more entries,\n               returns the undefined value in scalar context and the empty\n               list in list context.
readline=       readline EXPR\n       readline\n               Reads from the filehandle whose typeglob is contained in EXPR\n               (or from *ARGV if EXPR is not provided).  In scalar context,\n               each call reads and returns the next line until end-of-file is\n               reached, whereupon the subsequent call returns "undef".  In\n               list context, reads until end-of-file is reached and returns a\n               list of lines.  Note that the notion of "line" used here is\n               whatever you may have defined with $/ or\n               $INPUT_RECORD_SEPARATOR).  See "$/" in perlvar.
readlink=       readlink EXPR\n       readlink\n               Returns the value of a symbolic link, if symbolic links are\n               implemented.  If not, raises an exception.  If there is a\n               system error, returns the undefined value and sets $! (errno).\n               If EXPR is omitted, uses $_.
readpipe=       readpipe EXPR\n       readpipe\n               EXPR is executed as a system command.  The collected standard\n               output of the command is returned.  In scalar context, it comes\n               back as a single (potentially multi-line) string.  In list\n               context, returns a list of lines (however you've defined lines\n               with $/ or $INPUT_RECORD_SEPARATOR).  This is the internal\n               function implementing the "qx/EXPR/" operator, but you can use\n               it directly.  The "qx/EXPR/" operator is discussed in more\n               detail in "I/O Operators" in perlop.  If EXPR is omitted, uses\n               $_.
recv=       recv SOCKET,SCALAR,LENGTH,FLAGS\n               Receives a message on a socket.  Attempts to receive LENGTH\n               characters of data into variable SCALAR from the specified\n               SOCKET filehandle.  SCALAR will be grown or shrunk to the\n               length actually read.  Takes the same flags as the system call\n               of the same name.  Returns the address of the sender if\n               SOCKET's protocol supports this; returns an empty string\n               otherwise.  If there's an error, returns the undefined value.\n               This call is actually implemented in terms of _r_e_c_v_f_r_o_m(2)\n               system call.  See "UDP: Message Passing" in perlipc for\n               examples.
redo=       redo LABEL\n       redo    The "redo" command restarts the loop block without evaluating\n               the conditional again.  The "continue" block, if any, is not\n               executed.  If the LABEL is omitted, the command refers to the\n               innermost enclosing loop.  Programs that want to lie to\n               themselves about what was just input normally use this command:\n\n                   # a simpleminded Pascal comment stripper\n                   # (warning: assumes no { or } in strings)\n                   LINE: while (<STDIN>) {\n                       while (s|({.*}.*){.*}|$1 |) {}\n                       s|{.*}| |;\n                       if (s|{.*| |) {\n                           $front = $_;\n                           while (<STDIN>) {\n                               if (/}/) {  # end of comment?\n                                   s|^|$front\\{|;\n                                   redo LINE;\n                               }\n                           }\n                       }\n                       print;\n                   }\n\n               "redo" cannot be used to retry a block that returns a value\n               such as "eval {}", "sub {}" or "do {}", and should not be used\n               to exit a _g_r_e_p_(_) or _m_a_p_(_) operation.
ref=       ref EXPR\n       ref     Returns a non-empty string if EXPR is a reference, the empty\n               string otherwise. If EXPR is not specified, $_ will be used.\n               The value returned depends on the type of thing the reference\n               is a reference to.  Builtin types include:\n\n                   SCALAR\n                   ARRAY\n                   HASH\n                   CODE\n                   REF\n                   GLOB\n                   LVALUE\n                   FORMAT\n                   IO\n                   VSTRING\n                   Regexp\n\n               If the referenced object has been blessed into a package, then\n               that package name is returned instead.  You can think of "ref"\n               as a "typeof" operator.
rename=       rename OLDNAME,NEWNAME\n               Changes the name of a file; an existing file NEWNAME will be\n               clobbered.  Returns true for success, false otherwise.
require=       require VERSION\n       require EXPR\n       require Demands a version of Perl specified by VERSION, or demands some\n               semantics specified by EXPR or by $_ if EXPR is not supplied.
reset=       reset EXPR\n       reset   Generally used in a "continue" block at the end of a loop to\n               clear variables and reset "??" searches so that they work\n               again.  The expression is interpreted as a list of single\n               characters (hyphens allowed for ranges).  All variables and\n               arrays beginning with one of those letters are reset to their\n               pristine state.  If the expression is omitted, one-match\n               searches ("?pattern?") are reset to match again.  Only resets\n               variables or searches in the current package.  Always returns\n               1.  Examples:\n\n                   reset 'X';      # reset all X variables\n                   reset 'a-z';    # reset lower case variables\n                   reset;          # just reset ?one-time? searches\n\n               Resetting "A-Z" is not recommended because you'll wipe out your\n               @ARGV and @INC arrays and your %ENV hash.  Resets only package\n               variables; lexical variables are unaffected, but they clean\n               themselves up on scope exit anyway, so you'll probably want to\n               use them instead.  See "my".
return=       return EXPR\n       return  Returns from a subroutine, "eval", or "do FILE" with the value\n               given in EXPR.  Evaluation of EXPR may be in list, scalar, or\n               void context, depending on how the return value will be used,\n               and the context may vary from one execution to the next (see\n               "wantarray").  If no EXPR is given, returns an empty list in\n               list context, the undefined value in scalar context, and (of\n               course) nothing at all in void context.
reverse=       reverse LIST\n               In list context, returns a list value consisting of the\n               elements of LIST in the opposite order.  In scalar context,\n               concatenates the elements of LIST and returns a string value\n               with all characters in the opposite order.
rewinddir=       rewinddir DIRHANDLE\n               Sets the current position to the beginning of the directory for\n               the "readdir" routine on DIRHANDLE.
rindex=       rindex STR,SUBSTR,POSITION\n       rindex STR,SUBSTR\n               Works just like _i_n_d_e_x_(_) except that it returns the position of\n               the _l_a_s_t occurrence of SUBSTR in STR.  If POSITION is\n               specified, returns the last occurrence beginning at or before\n               that position.
rmdir=       rmdir FILENAME\n       rmdir   Deletes the directory specified by FILENAME if that directory\n               is empty.  If it succeeds it returns true, otherwise it returns\n               false and sets $! (errno).  If FILENAME is omitted, uses $_.
say=       say FILEHANDLE LIST\n       say LIST\n       say     Just like "print", but implicitly appends a newline.  "say\n               LIST" is simply an abbreviation for "{ local $\\ = "\\n"; print\n               LIST }".
scalar=       scalar EXPR\n               Forces EXPR to be interpreted in scalar context and returns the\n               value of EXPR.
seek=       seek FILEHANDLE,POSITION,WHENCE\n               Sets FILEHANDLE's position, just like the "fseek" call of\n               "stdio".  FILEHANDLE may be an expression whose value gives the\n               name of the filehandle.  The values for WHENCE are 0 to set the\n               new position _i_n _b_y_t_e_s to POSITION, 1 to set it to the current\n               position plus POSITION, and 2 to set it to EOF plus POSITION\n               (typically negative).  For WHENCE you may use the constants\n               "SEEK_SET", "SEEK_CUR", and "SEEK_END" (start of the file,\n               current position, end of the file) from the Fcntl module.\n               Returns 1 on success, 0 otherwise.
seekdir=       seekdir DIRHANDLE,POS\n               Sets the current position for the "readdir" routine on\n               DIRHANDLE.  POS must be a value returned by "telldir".\n               "seekdir" also has the same caveats about possible directory\n               compaction as the corresponding system library routine.
select=       select FILEHANDLE\n       select  Returns the currently selected filehandle.  If FILEHANDLE is\n               supplied, sets the new current default filehandle for output.\n               This has two effects: first, a "write" or a "print" without a\n               filehandle will default to this FILEHANDLE.  Second, references\n               to variables related to output will refer to this output\n               channel.  For example, if you have to set the top of form\n               format for more than one output channel, you might do the\n               following:\n\n                   select(REPORT1);\n                   $^ = 'report1_top';\n                   select(REPORT2);\n                   $^ = 'report2_top';\n\n               FILEHANDLE may be an expression whose value gives the name of\n               the actual filehandle.  Thus:\n\n                   $oldfh = select(STDERR); $| = 1; select($oldfh);\n\n               Some programmers may prefer to think of filehandles as objects\n               with methods, preferring to write the last example as:\n\n                   use IO::Handle;\n                   STDERR->autoflush(1);\n\n       select RBITS,WBITS,EBITS,TIMEOUT\n               This calls the _s_e_l_e_c_t(2) syscall with the bit masks specified,\n               which can be constructed using "fileno" and "vec", along these\n               lines:\n\n                   $rin = $win = $ein = '';\n                   vec($rin,fileno(STDIN),1) = 1;\n                   vec($win,fileno(STDOUT),1) = 1;\n                   $ein = $rin | $win;\n\n               If you want to select on many filehandles, you may wish to\n               write a subroutine like this:\n\n                   sub fhbits {\n                       my(@fhlist) = split(' ',$_[0]);\n                       my($bits);\n                       for (@fhlist) {\n                           vec($bits,fileno($_),1) = 1;\n                       }\n                       $bits;\n                   }\n                   $rin = fhbits('STDIN TTY SOCK');\n\n               The usual idiom is:\n\n                   ($nfound,$timeleft) =\n                     select($rout=$rin, $wout=$win, $eout=$ein, $timeout);\n\n               or to block until something becomes ready just do this\n\n                   $nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);\n\n               Most systems do not bother to return anything useful in\n               $timeleft, so calling _s_e_l_e_c_t_(_) in scalar context just returns\n               $nfound.
semctl=       semctl ID,SEMNUM,CMD,ARG\n               Calls the System V IPC function _s_e_m_c_t_l(2).  You'll probably\n               have to say\n\n                   use IPC::SysV;\n\n               first to get the correct constant definitions.  If CMD is\n               IPC_STAT or GETALL, then ARG must be a variable that will hold\n               the returned semid_ds structure or semaphore value array.\n               Returns like "ioctl": the undefined value for error, ""0 but\n               true"" for zero, or the actual return value otherwise.  The ARG\n               must consist of a vector of native short integers, which may be\n               created with "pack("s!",(0)x$nsem)".  See also "SysV IPC" in\n               perlipc, "IPC::SysV", "IPC::Semaphore" documentation.
semget=       semget KEY,NSEMS,FLAGS\n               Calls the System V IPC function _s_e_m_g_e_t(2).  Returns the\n               semaphore id, or the undefined value if there is an error.  See\n               also "SysV IPC" in perlipc, "IPC::SysV", "IPC::SysV::Semaphore"\n               documentation.
semop=       semop KEY,OPSTRING\n               Calls the System V IPC function _s_e_m_o_p(2) for semaphore\n               operations such as signalling and waiting.  OPSTRING must be a\n               packed array of semop structures.  Each semop structure can be\n               generated with "pack("s!3", $semnum, $semop, $semflag)".  The\n               length of OPSTRING implies the number of semaphore operations.\n               Returns true if successful, or false if there is an error.  As\n               an example, the following code waits on semaphore $semnum of\n               semaphore id $semid:\n\n                   $semop = pack("s!3", $semnum, -1, 0);\n                   die "Semaphore trouble: $!\\n" unless semop($semid, $semop);\n\n               To signal the semaphore, replace "-1" with 1.  See also "SysV\n               IPC" in perlipc, "IPC::SysV", and "IPC::SysV::Semaphore"\n               documentation.
send=       send SOCKET,MSG,FLAGS,TO\n       send SOCKET,MSG,FLAGS\n               Sends a message on a socket.  Attempts to send the scalar MSG\n               to the SOCKET filehandle.  Takes the same flags as the system\n               call of the same name.  On unconnected sockets, you must\n               specify a destination to _s_e_n_d _t_o, in which case it does a\n               _s_e_n_d_t_o(2) syscall.  Returns the number of characters sent, or\n               the undefined value on error.  The _s_e_n_d_m_s_g(2) syscall is\n               currently unimplemented.  See "UDP: Message Passing" in perlipc\n               for examples.
setgrent=       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
sethostent=       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
setnetent=       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
setpgrp=       setpgrp PID,PGRP\n               Sets the current process group for the specified PID, 0 for the\n               current process.  Raises an exception when used on a machine\n               that doesn't implement POSIX _s_e_t_p_g_i_d(2) or BSD _s_e_t_p_g_r_p(2).  If\n               the arguments are omitted, it defaults to "0,0".  Note that the\n               BSD 4.2 version of "setpgrp" does not accept any arguments, so\n               only "setpgrp(0,0)" is portable.  See also "POSIX::setsid()".
setpriority=       setpriority WHICH,WHO,PRIORITY\n               Sets the current priority for a process, a process group, or a\n               user.  (See _s_e_t_p_r_i_o_r_i_t_y(2).)  Raises an exception when used on\n               a machine that doesn't implement _s_e_t_p_r_i_o_r_i_t_y(2).
setprotoent=       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
setpwent=       setpwent\n       setgrent\n       sethostent STAYOPEN\n       setnetent STAYOPEN\n       setprotoent STAYOPEN\n       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
setservent=       setservent STAYOPEN\n       endpwent\n       endgrent\n       endhostent\n       endnetent\n       endprotoent\n       endservent\n               These routines are the same as their counterparts in the system\n               C library.  In list context, the return values from the various\n               get routines are as follows:\n\n                   ($name,$passwd,$uid,$gid,\n                      $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*\n                   ($name,$passwd,$gid,$members) = getgr*\n                   ($name,$aliases,$addrtype,$length,@addrs) = gethost*\n                   ($name,$aliases,$addrtype,$net) = getnet*\n                   ($name,$aliases,$proto) = getproto*\n                   ($name,$aliases,$port,$proto) = getserv*\n\n               (If the entry doesn't exist you get an empty list.)\n\n               The exact meaning of the $gcos field varies but it usually\n               contains the real name of the user (as opposed to the login\n               name) and other information pertaining to the user.  Beware,\n               however, that in many system users are able to change this\n               information and therefore it cannot be trusted and therefore\n               the $gcos is tainted (see perlsec).  The $passwd and $shell,\n               user's encrypted password and login shell, are also tainted,\n               because of the same reason.
setsockopt=       setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL\n               Sets the socket option requested.  Returns undefined if there\n               is an error.  Use integer constants provided by the "Socket"\n               module for LEVEL and OPNAME.  Values for LEVEL can also be\n               obtained from getprotobyname.  OPTVAL might either be a packed\n               string or an integer.  An integer OPTVAL is shorthand for\n               pack("i", OPTVAL).
shift=       shift ARRAY\n       shift   Shifts the first value of the array off and returns it,\n               shortening the array by 1 and moving everything down.  If there\n               are no elements in the array, returns the undefined value.  If\n               ARRAY is omitted, shifts the @_ array within the lexical scope\n               of subroutines and formats, and the @ARGV array outside a\n               subroutine and also within the lexical scopes established by\n               the "eval STRING", "BEGIN {}", "INIT {}", "CHECK {}",\n               "UNITCHECK {}" and "END {}" constructs.
shmctl=       shmctl ID,CMD,ARG\n               Calls the System V IPC function shmctl.  You'll probably have\n               to say\n\n                   use IPC::SysV;\n\n               first to get the correct constant definitions.  If CMD is\n               "IPC_STAT", then ARG must be a variable that will hold the\n               returned "shmid_ds" structure.  Returns like ioctl: the\n               undefined value for error, "0 but true" for zero, or the actual\n               return value otherwise.  See also "SysV IPC" in perlipc and\n               "IPC::SysV" documentation.
shmget=       shmget KEY,SIZE,FLAGS\n               Calls the System V IPC function shmget.  Returns the shared\n               memory segment id, or the undefined value if there is an error.\n               See also "SysV IPC" in perlipc and "IPC::SysV" documentation.
shmread=       shmread ID,VAR,POS,SIZE\n       shmwrite ID,STRING,POS,SIZE\n               Reads or writes the System V shared memory segment ID starting\n               at position POS for size SIZE by attaching to it, copying\n               in/out, and detaching from it.  When reading, VAR must be a\n               variable that will hold the data read.  When writing, if STRING\n               is too long, only SIZE bytes are used; if STRING is too short,\n               nulls are written to fill out SIZE bytes.  Return true if\n               successful, or false if there is an error.  _s_h_m_r_e_a_d_(_) taints\n               the variable. See also "SysV IPC" in perlipc, "IPC::SysV"\n               documentation, and the "IPC::Shareable" module from CPAN.
shmwrite=       shmwrite ID,STRING,POS,SIZE\n               Reads or writes the System V shared memory segment ID starting\n               at position POS for size SIZE by attaching to it, copying\n               in/out, and detaching from it.  When reading, VAR must be a\n               variable that will hold the data read.  When writing, if STRING\n               is too long, only SIZE bytes are used; if STRING is too short,\n               nulls are written to fill out SIZE bytes.  Return true if\n               successful, or false if there is an error.  _s_h_m_r_e_a_d_(_) taints\n               the variable. See also "SysV IPC" in perlipc, "IPC::SysV"\n               documentation, and the "IPC::Shareable" module from CPAN.
shutdown=       shutdown SOCKET,HOW\n               Shuts down a socket connection in the manner indicated by HOW,\n               which has the same interpretation as in the syscall of the same\n               name.
sin=       sin EXPR\n       sin     Returns the sine of EXPR (expressed in radians).  If EXPR is\n               omitted, returns sine of $_.
sleep=       sleep EXPR\n       sleep   Causes the script to sleep for (integer) EXPR seconds, or\n               forever if no argument is given.  Returns the integer number of\n               seconds actually slept.
socket=       socket SOCKET,DOMAIN,TYPE,PROTOCOL\n               Opens a socket of the specified kind and attaches it to\n               filehandle SOCKET.  DOMAIN, TYPE, and PROTOCOL are specified\n               the same as for the syscall of the same name.  You should "use\n               Socket" first to get the proper definitions imported.  See the\n               examples in "Sockets: Client/Server Communication" in perlipc.
socketpair=       socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL\n               Creates an unnamed pair of sockets in the specified domain, of\n               the specified type.  DOMAIN, TYPE, and PROTOCOL are specified\n               the same as for the syscall of the same name.  If\n               unimplemented, raises an exception.  Returns true if\n               successful.
sort=       sort SUBNAME LIST\n       sort BLOCK LIST\n       sort LIST\n               In list context, this sorts the LIST and returns the sorted\n               list value.  In scalar context, the behaviour of "sort()" is\n               undefined.
splice=       splice ARRAY,OFFSET,LENGTH,LIST\n       splice ARRAY,OFFSET,LENGTH\n       splice ARRAY,OFFSET\n       splice ARRAY\n               Removes the elements designated by OFFSET and LENGTH from an\n               array, and replaces them with the elements of LIST, if any.  In\n               list context, returns the elements removed from the array.  In\n               scalar context, returns the last element removed, or "undef" if\n               no elements are removed.  The array grows or shrinks as\n               necessary.  If OFFSET is negative then it starts that far from\n               the end of the array.  If LENGTH is omitted, removes everything\n               from OFFSET onward.  If LENGTH is negative, removes the\n               elements from OFFSET onward except for -LENGTH elements at the\n               end of the array.  If both OFFSET and LENGTH are omitted,\n               removes everything. If OFFSET is past the end of the array,\n               Perl issues a warning, and splices at the end of the array.
split=       split /PATTERN/,EXPR,LIMIT\n       split /PATTERN/,EXPR\n       split /PATTERN/\n       split   Splits the string EXPR into a list of strings and returns that\n               list.  By default, empty leading fields are preserved, and\n               empty trailing ones are deleted.  (If all fields are empty,\n               they are considered to be trailing.)\n\n               In scalar context, returns the number of fields found.
sprintf=       sprintf FORMAT, LIST\n               Returns a string formatted by the usual "printf" conventions of\n               the C library function "sprintf".  See below for more details\n               and see sprintf(3) or printf(3) on your system for an\n               explanation of the general principles.
sqrt=       sqrt EXPR\n       sqrt    Return the positive square root of EXPR.  If EXPR is omitted,\n               uses $_.  Works only for non-negative operands unless you've\n               loaded the "Math::Complex" module.
srand=       srand EXPR\n       srand   Sets the random number seed for the "rand" operator.
stat=       stat FILEHANDLE\n       stat EXPR\n       stat DIRHANDLE\n       stat    Returns a 13-element list giving the status info for a file,\n               either the file opened via FILEHANDLE or DIRHANDLE, or named by\n               EXPR.  If EXPR is omitted, it stats $_.  Returns the empty list\n               if "stat" fails.  Typically used as follows:\n\n                   ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,\n                      $atime,$mtime,$ctime,$blksize,$blocks)\n                          = stat($filename);\n\n               Not all fields are supported on all filesystem types.  Here are\n               the meanings of the fields:\n\n                 0 dev      device number of filesystem\n                 1 ino      inode number\n                 2 mode     file mode  (type and permissions)\n                 3 nlink    number of (hard) links to the file\n                 4 uid      numeric user ID of file's owner\n                 5 gid      numeric group ID of file's owner\n                 6 rdev     the device identifier (special files only)\n                 7 size     total size of file, in bytes\n                 8 atime    last access time in seconds since the epoch\n                 9 mtime    last modify time in seconds since the epoch\n                10 ctime    inode change time in seconds since the epoch (*)\n                11 blksize  preferred block size for file system I/O\n                12 blocks   actual number of blocks allocated\n\n               (The epoch was at 00:00 January 1, 1970 GMT.)\n\n               (*) Not all fields are supported on all filesystem types.\n               Notably, the ctime field is non-portable.  In particular, you\n               cannot expect it to be a "creation time", see "Files and\n               Filesystems" in perlport for details.
state=       state EXPR\n       state TYPE EXPR\n       state EXPR : ATTRS\n       state TYPE EXPR : ATTRS\n               "state" declares a lexically scoped variable, just like "my"\n               does.  However, those variables will never be reinitialized,\n               contrary to lexical variables that are reinitialized each time\n               their enclosing block is entered.
study=       study SCALAR\n       study   Takes extra time to study SCALAR ($_ if unspecified) in\n               anticipation of doing many pattern matches on the string before\n               it is next modified.  This may or may not save time, depending\n               on the nature and number of patterns you are searching on, and\n               on the distribution of character frequencies in the string to\n               be searched; you probably want to compare run times with and\n               without it to see which runs faster.  Those loops that scan for\n               many short constant strings (including the constant parts of\n               more complex patterns) will benefit most.  You may have only\n               one "study" active at a time: if you study a different scalar\n               the first is "unstudied".  (The way "study" works is this: a\n               linked list of every character in the string to be searched is\n               made, so we know, for example, where all the 'k' characters\n               are.  From each search string, the rarest character is\n               selected, based on some static frequency tables constructed\n               from some C programs and English text.  Only those places that\n               contain this "rarest" character are examined.)\n\n               For example, here is a loop that inserts index producing\n               entries before any line containing a certain pattern:\n\n                   while (<>) {\n                       study;\n                       print ".IX foo\\n"    if /\\bfoo\\b/;\n                       print ".IX bar\\n"    if /\\bbar\\b/;\n                       print ".IX blurfl\\n" if /\\bblurfl\\b/;\n                       # ...\n                       print;\n                   }\n\n               In searching for "/\\bfoo\\b/", only locations in $_ that contain\n               "f" will be looked at, because "f" is rarer than "o".  In\n               general, this is a big win except in pathological cases.  The\n               only question is whether it saves you more time than it took to\n               build the linked list in the first place.
substr=       substr EXPR,OFFSET,LENGTH,REPLACEMENT\n       substr EXPR,OFFSET,LENGTH\n       substr EXPR,OFFSET\n               Extracts a substring out of EXPR and returns it.  First\n               character is at offset 0, or whatever you've set $[ to (but\n               don't do that).  If OFFSET is negative (or more precisely, less\n               than $[), starts that far from the end of the string.  If\n               LENGTH is omitted, returns everything to the end of the string.\n               If LENGTH is negative, leaves that many characters off the end\n               of the string.
symlink=       symlink OLDFILE,NEWFILE\n               Creates a new filename symbolically linked to the old filename.\n               Returns 1 for success, 0 otherwise.  On systems that don't\n               support symbolic links, raises an exception.  To check for\n               that, use eval:\n\n                   $symlink_exists = eval { symlink("",""); 1 };
syscall=       syscall NUMBER, LIST\n               Calls the system call specified as the first element of the\n               list, passing the remaining elements as arguments to the system\n               call.  If unimplemented, raises an exception.  The arguments\n               are interpreted as follows: if a given argument is numeric, the\n               argument is passed as an int.  If not, the pointer to the\n               string value is passed.  You are responsible to make sure a\n               string is pre-extended long enough to receive any result that\n               might be written into a string.  You can't use a string literal\n               (or other read-only string) as an argument to "syscall" because\n               Perl has to assume that any string pointer might be written\n               through.  If your integer arguments are not literals and have\n               never been interpreted in a numeric context, you may need to\n               add 0 to them to force them to look like numbers.  This\n               emulates the "syswrite" function (or vice versa):\n\n                   require 'syscall.ph';        # may need to run h2ph\n                   $s = "hi there\\n";\n                   syscall(&SYS_write, fileno(STDOUT), $s, length $s);\n\n               Note that Perl supports passing of up to only 14 arguments to\n               your syscall, which in practice should (usually) suffice.
sysopen=       sysopen FILEHANDLE,FILENAME,MODE\n       sysopen FILEHANDLE,FILENAME,MODE,PERMS\n               Opens the file whose filename is given by FILENAME, and\n               associates it with FILEHANDLE.  If FILEHANDLE is an expression,\n               its value is used as the name of the real filehandle wanted.\n               This function calls the underlying operating system's "open"\n               function with the parameters FILENAME, MODE, PERMS.
sysread=       sysread FILEHANDLE,SCALAR,LENGTH,OFFSET\n       sysread FILEHANDLE,SCALAR,LENGTH\n               Attempts to read LENGTH bytes of data into variable SCALAR from\n               the specified FILEHANDLE, using the _r_e_a_d(2).  It bypasses\n               buffered IO, so mixing this with other kinds of reads, "print",\n               "write", "seek", "tell", or "eof" can cause confusion because\n               the perlio or stdio layers usually buffers data.  Returns the\n               number of bytes actually read, 0 at end of file, or undef if\n               there was an error (in the latter case $! is also set).  SCALAR\n               will be grown or shrunk so that the last byte actually read is\n               the last byte of the scalar after the read.
sysseek=       sysseek FILEHANDLE,POSITION,WHENCE\n               Sets FILEHANDLE's system position in bytes using _l_s_e_e_k(2).\n               FILEHANDLE may be an expression whose value gives the name of\n               the filehandle.  The values for WHENCE are 0 to set the new\n               position to POSITION, 1 to set the it to the current position\n               plus POSITION, and 2 to set it to EOF plus POSITION (typically\n               negative).
system=       system LIST\n       system PROGRAM LIST\n               Does exactly the same thing as "exec LIST", except that a fork\n               is done first, and the parent process waits for the child\n               process to exit.  Note that argument processing varies\n               depending on the number of arguments.  If there is more than\n               one argument in LIST, or if LIST is an array with more than one\n               value, starts the program given by the first element of the\n               list with arguments given by the rest of the list.  If there is\n               only one scalar argument, the argument is checked for shell\n               metacharacters, and if there are any, the entire argument is\n               passed to the system's command shell for parsing (this is\n               "/bin/sh -c" on Unix platforms, but varies on other platforms).\n               If there are no shell metacharacters in the argument, it is\n               split into words and passed directly to "execvp", which is more\n               efficient.
syswrite=       syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET\n       syswrite FILEHANDLE,SCALAR,LENGTH\n       syswrite FILEHANDLE,SCALAR\n               Attempts to write LENGTH bytes of data from variable SCALAR to\n               the specified FILEHANDLE, using _w_r_i_t_e(2).  If LENGTH is not\n               specified, writes whole SCALAR.  It bypasses buffered IO, so\n               mixing this with reads (other than sysread()), "print",\n               "write", "seek", "tell", or "eof" may cause confusion because\n               the perlio and stdio layers usually buffers data.  Returns the\n               number of bytes actually written, or "undef" if there was an\n               error (in this case the errno variable $! is also set).  If the\n               LENGTH is greater than the data available in the SCALAR after\n               the OFFSET, only as much data as is available will be written.
tell=       tell FILEHANDLE\n       tell    Returns the current position _i_n _b_y_t_e_s for FILEHANDLE, or -1 on\n               error.  FILEHANDLE may be an expression whose value gives the\n               name of the actual filehandle.  If FILEHANDLE is omitted,\n               assumes the file last read.
telldir=       telldir DIRHANDLE\n               Returns the current position of the "readdir" routines on\n               DIRHANDLE.  Value may be given to "seekdir" to access a\n               particular location in a directory.  "telldir" has the same\n               caveats about possible directory compaction as the\n               corresponding system library routine.
tie=       tie VARIABLE,CLASSNAME,LIST\n               This function binds a variable to a package class that will\n               provide the implementation for the variable.  VARIABLE is the\n               name of the variable to be enchanted.  CLASSNAME is the name of\n               a class implementing objects of correct type.  Any additional\n               arguments are passed to the "new" method of the class (meaning\n               "TIESCALAR", "TIEHANDLE", "TIEARRAY", or "TIEHASH").  Typically\n               these are arguments such as might be passed to the "dbm_open()"\n               function of C.  The object returned by the "new" method is also\n               returned by the "tie" function, which would be useful if you\n               want to access other methods in CLASSNAME.
tied=       tied VARIABLE\n               Returns a reference to the object underlying VARIABLE (the same\n               value that was originally returned by the "tie" call that bound\n               the variable to a package.)  Returns the undefined value if\n               VARIABLE isn't tied to a package.
time=       time    Returns the number of non-leap seconds since whatever time the\n               system considers to be the epoch, suitable for feeding to\n               "gmtime" and "localtime". On most systems the epoch is 00:00:00\n               UTC, January 1, 1970; a prominent exception being Mac OS\n               Classic which uses 00:00:00, January 1, 1904 in the current\n               local time zone for its epoch.
times=       times   Returns a four-element list giving the user and system times,\n               in seconds, for this process and the children of this process.
truncate=       truncate FILEHANDLE,LENGTH\n       truncate EXPR,LENGTH\n               Truncates the file opened on FILEHANDLE, or named by EXPR, to\n               the specified length.  Raises an exception if truncate isn't\n               implemented on your system.  Returns true if successful, the\n               undefined value otherwise.
uc=       uc EXPR\n       uc      Returns an uppercased version of EXPR.  This is the internal\n               function implementing the "\\U" escape in double-quoted strings.\n               It does not attempt to do titlecase mapping on initial letters.\n               See "ucfirst" for that.
ucfirst=       ucfirst EXPR\n       ucfirst Returns the value of EXPR with the first character in uppercase\n               (titlecase in Unicode).  This is the internal function\n               implementing the "\\u" escape in double-quoted strings.
umask=       umask EXPR\n       umask   Sets the umask for the process to EXPR and returns the previous\n               value.  If EXPR is omitted, merely returns the current umask.
undef=       undef EXPR\n       undef   Undefines the value of EXPR, which must be an lvalue.  Use only\n               on a scalar value, an array (using "@"), a hash (using "%"), a\n               subroutine (using "&"), or a typeglob (using "*").  Saying\n               "undef $hash{$key}" will probably not do what you expect on\n               most predefined variables or DBM list values, so don't do that;\n               see delete.  Always returns the undefined value.  You can omit\n               the EXPR, in which case nothing is undefined, but you still get\n               an undefined value that you could, for instance, return from a\n               subroutine, assign to a variable, or pass as a parameter.\n               Examples:\n\n                   undef $foo;\n                   undef $bar{'blurfl'};      # Compare to: delete $bar{'blurfl'};\n                   undef @ary;\n                   undef %hash;\n                   undef &mysub;\n                   undef *xyz;       # destroys $xyz, @xyz, %xyz, &xyz, etc.\n                   return (wantarray ? (undef, $errmsg) : undef) if $they_blew_it;\n                   select undef, undef, undef, 0.25;\n                   ($a, $b, undef, $c) = &foo;       # Ignore third value returned\n\n               Note that this is a unary operator, not a list operator.
unlink=       unlink LIST\n       unlink  Deletes a list of files. On success, it returns the number of\n               files it successfully deleted. On failure, it returns false and\n               sets $!  (errno):\n\n                   my $unlinked = unlink 'a', 'b', 'c';\n                   unlink @goners;\n                   unlink glob "*.bak";\n\n               On error, "unlink" will not tell you which files it could not\n               remove.  If you want to know which files you could not remove,\n               try them one at a time:\n\n                    foreach my $file ( @goners ) {\n                        unlink $file or warn "Could not unlink $file: $!";\n                    }\n\n               Note: "unlink" will not attempt to delete directories unless\n               you are superuser and the --UU flag is supplied to Perl. Even if\n               these conditions are met, be warned that unlinking a directory\n               can inflict damage on your filesystem.  Finally, using "unlink"\n               on directories is not supported on many operating systems.  Use\n               "rmdir" instead.
unpack=       unpack TEMPLATE,EXPR\n       unpack TEMPLATE\n               "unpack" does the reverse of "pack": it takes a string and\n               expands it out into a list of values.  (In scalar context, it\n               returns merely the first value produced.)\n\n               If EXPR is omitted, unpacks the $_ string.  See perlpacktut for\n               an introduction to this function.
unshift=       unshift ARRAY,LIST\n               Does the opposite of a "shift".  Or the opposite of a "push",\n               depending on how you look at it.  Prepends list to the front of\n               the array, and returns the new number of elements in the array.
untie=       untie VARIABLE\n               Breaks the binding between a variable and a package.  (See\n               "tie".)  Has no effect if the variable is not tied.
use=       use Module VERSION LIST\n       use Module VERSION\n       use Module LIST\n       use Module\n       use VERSION\n               Imports some semantics into the current package from the named\n               module, generally by aliasing certain subroutine or variable\n               names into your package.  It is exactly equivalent to\n\n                   BEGIN { require Module; Module->import( LIST ); }\n\n               except that Module _m_u_s_t be a bareword.
utime=       utime LIST\n               Changes the access and modification times on each file of a\n               list of files.  The first two elements of the list must be the\n               NUMERICAL access and modification times, in that order.\n               Returns the number of files successfully changed.  The inode\n               change time of each file is set to the current time.  For\n               example, this code has the same effect as the Unix _t_o_u_c_h(1)\n               command when the files _a_l_r_e_a_d_y _e_x_i_s_t and belong to the user\n               running the program:\n\n                   #!/usr/bin/perl\n                   $atime = $mtime = time;\n                   utime $atime, $mtime, @ARGV;\n\n               Since Perl 5.7.2, if the first two elements of the list are\n               "undef", the _u_t_i_m_e(2) syscall from your C library is called\n               with a null second argument. On most systems, this will set the\n               file's access and modification times to the current time (i.e.,\n               equivalent to the example above) and will work even on files\n               you don't own provided you have write permission:\n\n                   for $file (@ARGV) {\n                       utime(undef, undef, $file)\n                           || warn "couldn't touch $file: $!";\n                   }\n\n               Under NFS this will use the time of the NFS server, not the\n               time of the local machine.  If there is a time synchronization\n               problem, the NFS server and local machine will have different\n               times.  The Unix _t_o_u_c_h(1) command will in fact normally use\n               this form instead of the one shown in the first example.
values=       values HASH\n       values ARRAY\n               Returns a list consisting of all the values of the named hash,\n               or the values of an array. (In a scalar context, returns the\n               number of values.)\n\n               The values are returned in an apparently random order.  The\n               actual random order is subject to change in future versions of\n               Perl, but it is guaranteed to be the same order as either the\n               "keys" or "each" function would produce on the same\n               (unmodified) hash.  Since Perl 5.8.1 the ordering is different\n               even between different runs of Perl for security reasons (see\n               "Algorithmic Complexity Attacks" in perlsec).
vec=       vec EXPR,OFFSET,BITS\n               Treats the string in EXPR as a bit vector made up of elements\n               of width BITS, and returns the value of the element specified\n               by OFFSET as an unsigned integer.  BITS therefore specifies the\n               number of bits that are reserved for each element in the bit\n               vector.  This must be a power of two from 1 to 32 (or 64, if\n               your platform supports that).
wait=       wait    Behaves like _w_a_i_t(2) on your system: it waits for a child\n               process to terminate and returns the pid of the deceased\n               process, or "-1" if there are no child processes.  The status\n               is returned in $?  and "${^CHILD_ERROR_NATIVE}".  Note that a\n               return value of "-1" could mean that child processes are being\n               automatically reaped, as described in perlipc.
waitpid=       waitpid PID,FLAGS\n               Waits for a particular child process to terminate and returns\n               the pid of the deceased process, or "-1" if there is no such\n               child process.  On some systems, a value of 0 indicates that\n               there are processes still running.  The status is returned in\n               $? and "${^CHILD_ERROR_NATIVE}".  If you say\n\n                   use POSIX ":sys_wait_h";\n                   #...\n                   do {\n                       $kid = waitpid(-1, WNOHANG);\n                   } while $kid > 0;\n\n               then you can do a non-blocking wait for all pending zombie\n               processes.  Non-blocking wait is available on machines\n               supporting either the _w_a_i_t_p_i_d(2) or _w_a_i_t_4(2) syscalls.\n               However, waiting for a particular pid with FLAGS of 0 is\n               implemented everywhere.  (Perl emulates the system call by\n               remembering the status values of processes that have exited but\n               have not been harvested by the Perl script yet.)\n\n               Note that on some systems, a return value of "-1" could mean\n               that child processes are being automatically reaped.  See\n               perlipc for details, and for other examples.
wantarray=       wantarray\n               Returns true if the context of the currently executing\n               subroutine or "eval" is looking for a list value.  Returns\n               false if the context is looking for a scalar.  Returns the\n               undefined value if the context is looking for no value (void\n               context).
warn=       warn LIST\n               Prints the value of LIST to STDERR.  If the last element of\n               LIST does not end in a newline, it appends the same file/line\n               number text as "die" does.
write=       write FILEHANDLE\n       write EXPR\n       write   Writes a formatted record (possibly multi-line) to the\n               specified FILEHANDLE, using the format associated with that\n               file.  By default the format for a file is the one having the\n               same name as the filehandle, but the format for the current\n               output channel (see the "select" function) may be set\n               explicitly by assigning the name of the format to the $~\n               variable.
-r=
-w=
-x=
-o=
-R=
-W=
-X=
-O=
-e=
-z=
-s=
-f=
-d=
-l=
-p=
-S=
-b=
-c=
-t=
-u=
-g=
-k=
-T=
-B=
-M=
-A=
-C=
