$a=       $a\n       $b      Special package variables when using _s_o_r_t_(_), see "sort" in\n               perlfunc.  Because of this specialness $a and $b don't need to\n               be declared (using use vars, or _o_u_r_(_)) even when using the\n               "strict 'vars'" pragma.  Don't lexicalize them with "my $a" or\n               "my $b" if you want to be able to use them in the _s_o_r_t_(_)\n               comparison block or function.
$b=       $a\n       $b      Special package variables when using _s_o_r_t_(_), see "sort" in\n               perlfunc.  Because of this specialness $a and $b don't need to\n               be declared (using use vars, or _o_u_r_(_)) even when using the\n               "strict 'vars'" pragma.  Don't lexicalize them with "my $a" or\n               "my $b" if you want to be able to use them in the _s_o_r_t_(_)\n               comparison block or function.
$_=       $ARG\n       $_      The default input and pattern-searching space.  The following\n               pairs are equivalent:\n\n                   while (<>) {...}    # equivalent only in while!\n                   while (defined($_ = <>)) {...}\n\n                   /^Subject:/\n                   $_ =~ /^Subject:/\n\n                   tr/a-z/A-Z/\n                   $_ =~ tr/a-z/A-Z/\n\n                   chomp\n                   chomp($_)\n\n               Here are the places where Perl will assume $_ even if you don't\n               use it:\n\n               +o  The following functions:\n\n                  abs, alarm, chomp, chop, chr, chroot, cos, defined, eval,\n                  exp, glob, hex, int, lc, lcfirst, length, log, lstat, mkdir,\n                  oct, ord, pos, print, quotemeta, readlink, readpipe, ref,\n                  require, reverse (in scalar context only), rmdir, sin, split\n                  (on its second argument), sqrt, stat, study, uc, ucfirst,\n                  unlink, unpack.
$ARG=       $ARG\n       $_      The default input and pattern-searching space.  The following\n               pairs are equivalent:\n\n                   while (<>) {...}    # equivalent only in while!\n                   while (defined($_ = <>)) {...}\n\n                   /^Subject:/\n                   $_ =~ /^Subject:/\n\n                   tr/a-z/A-Z/\n                   $_ =~ tr/a-z/A-Z/\n\n                   chomp\n                   chomp($_)\n\n               Here are the places where Perl will assume $_ even if you don't\n               use it:\n\n               +o  The following functions:\n\n                  abs, alarm, chomp, chop, chr, chroot, cos, defined, eval,\n                  exp, glob, hex, int, lc, lcfirst, length, log, lstat, mkdir,\n                  oct, ord, pos, print, quotemeta, readlink, readpipe, ref,\n                  require, reverse (in scalar context only), rmdir, sin, split\n                  (on its second argument), sqrt, stat, study, uc, ucfirst,\n                  unlink, unpack.
$&=       $MATCH\n       $&      The string matched by the last successful pattern match (not\n               counting any matches hidden within a BLOCK or _e_v_a_l_(_) enclosed\n               by the current BLOCK).  (Mnemonic: like & in some editors.)\n               This variable is read-only and dynamically scoped to the\n               current BLOCK.
$MATCH=       $MATCH\n       $&      The string matched by the last successful pattern match (not\n               counting any matches hidden within a BLOCK or _e_v_a_l_(_) enclosed\n               by the current BLOCK).  (Mnemonic: like & in some editors.)\n               This variable is read-only and dynamically scoped to the\n               current BLOCK.
$`=       $PREMATCH\n       $`      The string preceding whatever was matched by the last\n               successful pattern match (not counting any matches hidden\n               within a BLOCK or eval enclosed by the current BLOCK).\n               (Mnemonic: "`" often precedes a quoted string.)  This variable\n               is read-only.
$PREMATCH=       $PREMATCH\n       $`      The string preceding whatever was matched by the last\n               successful pattern match (not counting any matches hidden\n               within a BLOCK or eval enclosed by the current BLOCK).\n               (Mnemonic: "`" often precedes a quoted string.)  This variable\n               is read-only.
$'=       $POSTMATCH\n       $'      The string following whatever was matched by the last\n               successful pattern match (not counting any matches hidden\n               within a BLOCK or _e_v_a_l_(_) enclosed by the current BLOCK).\n               (Mnemonic: "'" often follows a quoted string.)  Example:\n\n                   local $_ = 'abcdefghi';\n                   /def/;\n                   print "$`:$&:$'\\n";         # prints abc:def:ghi\n\n               This variable is read-only and dynamically scoped to the\n               current BLOCK.
$POSTMATCH=       $POSTMATCH\n       $'      The string following whatever was matched by the last\n               successful pattern match (not counting any matches hidden\n               within a BLOCK or _e_v_a_l_(_) enclosed by the current BLOCK).\n               (Mnemonic: "'" often follows a quoted string.)  Example:\n\n                   local $_ = 'abcdefghi';\n                   /def/;\n                   print "$`:$&:$'\\n";         # prints abc:def:ghi\n\n               This variable is read-only and dynamically scoped to the\n               current BLOCK.
$+=       $LAST_PAREN_MATCH\n       $+      The text matched by the last bracket of the last successful\n               search pattern.  This is useful if you don't know which one of\n               a set of alternative patterns matched. For example:\n\n                   /Version: (.*)|Revision: (.*)/ && ($rev = $+);\n\n               (Mnemonic: be positive and forward looking.)  This variable is\n               read-only and dynamically scoped to the current BLOCK.
$LAST_PAREN_MATCH=       $LAST_PAREN_MATCH\n       $+      The text matched by the last bracket of the last successful\n               search pattern.  This is useful if you don't know which one of\n               a set of alternative patterns matched. For example:\n\n                   /Version: (.*)|Revision: (.*)/ && ($rev = $+);\n\n               (Mnemonic: be positive and forward looking.)  This variable is\n               read-only and dynamically scoped to the current BLOCK.
$*=       $*      $* used to be a variable that enabled multiline matching.\n               After a deprecation cycle, its magic was removed in Perl 5.10.\n               Using it now triggers a warning: "$* is no longer supported".\n               Use the "/s" and "/m" regexp modifiers instead.
$MULTILINE_MATCHING=
$.=       HANDLE->input_line_number(EXPR)\n       $INPUT_LINE_NUMBER\n       $NR\n       $.      Current line number for the last filehandle accessed.
$INPUT_LINE_NUMBER=       HANDLE->input_line_number(EXPR)\n       $INPUT_LINE_NUMBER\n       $NR\n       $.      Current line number for the last filehandle accessed.
$NR=       HANDLE->input_line_number(EXPR)\n       $INPUT_LINE_NUMBER\n       $NR\n       $.      Current line number for the last filehandle accessed.
$/=       IO::Handle->input_record_separator(EXPR)\n       $INPUT_RECORD_SEPARATOR\n       $RS\n       $/      The input record separator, newline by default.  This\n               influences Perl's idea of what a "line" is.  Works like aawwkk's\n               RS variable, including treating empty lines as a terminator if\n               set to the null string.  (An empty line cannot contain any\n               spaces or tabs.)  You may set it to a multi-character string to\n               match a multi-character terminator, or to "undef" to read\n               through the end of file.  Setting it to "\\n\\n" means something\n               slightly different than setting to "", if the file contains\n               consecutive empty lines.  Setting to "" will treat two or more\n               consecutive empty lines as a single empty line.  Setting to\n               "\\n\\n" will blindly assume that the next input character\n               belongs to the next paragraph, even if it's a newline.\n               (Mnemonic: / delimits line boundaries when quoting poetry.)\n\n                   local $/;           # enable "slurp" mode\n                   local $_ = <FH>;    # whole file now here\n                   s/\\n[ \\t]+/ /g;\n\n               Remember: the value of $/ is a string, not a regex.  aawwkk has to\n               be better for something. :-)\n\n               Setting $/ to a reference to an integer, scalar containing an\n               integer, or scalar that's convertible to an integer will\n               attempt to read records instead of lines, with the maximum\n               record size being the referenced integer.  So this:\n\n                   local $/ = \\32768; # or \\"32768", or \\$var_containing_32768\n                   open my $fh, "<", $myfile or die $!;\n                   local $_ = <$fh>;\n\n               will read a record of no more than 32768 bytes from FILE.  If\n               you're not reading from a record-oriented file (or your OS\n               doesn't have record-oriented files), then you'll likely get a\n               full chunk of data with every read.  If a record is larger than\n               the record size you've set, you'll get the record back in\n               pieces.  Trying to set the record size to zero or less will\n               cause reading in the (rest of the) whole file.
$INPUT_RECORD_SEPARATOR=       IO::Handle->input_record_separator(EXPR)\n       $INPUT_RECORD_SEPARATOR\n       $RS\n       $/      The input record separator, newline by default.  This\n               influences Perl's idea of what a "line" is.  Works like aawwkk's\n               RS variable, including treating empty lines as a terminator if\n               set to the null string.  (An empty line cannot contain any\n               spaces or tabs.)  You may set it to a multi-character string to\n               match a multi-character terminator, or to "undef" to read\n               through the end of file.  Setting it to "\\n\\n" means something\n               slightly different than setting to "", if the file contains\n               consecutive empty lines.  Setting to "" will treat two or more\n               consecutive empty lines as a single empty line.  Setting to\n               "\\n\\n" will blindly assume that the next input character\n               belongs to the next paragraph, even if it's a newline.\n               (Mnemonic: / delimits line boundaries when quoting poetry.)\n\n                   local $/;           # enable "slurp" mode\n                   local $_ = <FH>;    # whole file now here\n                   s/\\n[ \\t]+/ /g;\n\n               Remember: the value of $/ is a string, not a regex.  aawwkk has to\n               be better for something. :-)\n\n               Setting $/ to a reference to an integer, scalar containing an\n               integer, or scalar that's convertible to an integer will\n               attempt to read records instead of lines, with the maximum\n               record size being the referenced integer.  So this:\n\n                   local $/ = \\32768; # or \\"32768", or \\$var_containing_32768\n                   open my $fh, "<", $myfile or die $!;\n                   local $_ = <$fh>;\n\n               will read a record of no more than 32768 bytes from FILE.  If\n               you're not reading from a record-oriented file (or your OS\n               doesn't have record-oriented files), then you'll likely get a\n               full chunk of data with every read.  If a record is larger than\n               the record size you've set, you'll get the record back in\n               pieces.  Trying to set the record size to zero or less will\n               cause reading in the (rest of the) whole file.
$RS=       IO::Handle->input_record_separator(EXPR)\n       $INPUT_RECORD_SEPARATOR\n       $RS\n       $/      The input record separator, newline by default.  This\n               influences Perl's idea of what a "line" is.  Works like aawwkk's\n               RS variable, including treating empty lines as a terminator if\n               set to the null string.  (An empty line cannot contain any\n               spaces or tabs.)  You may set it to a multi-character string to\n               match a multi-character terminator, or to "undef" to read\n               through the end of file.  Setting it to "\\n\\n" means something\n               slightly different than setting to "", if the file contains\n               consecutive empty lines.  Setting to "" will treat two or more\n               consecutive empty lines as a single empty line.  Setting to\n               "\\n\\n" will blindly assume that the next input character\n               belongs to the next paragraph, even if it's a newline.\n               (Mnemonic: / delimits line boundaries when quoting poetry.)\n\n                   local $/;           # enable "slurp" mode\n                   local $_ = <FH>;    # whole file now here\n                   s/\\n[ \\t]+/ /g;\n\n               Remember: the value of $/ is a string, not a regex.  aawwkk has to\n               be better for something. :-)\n\n               Setting $/ to a reference to an integer, scalar containing an\n               integer, or scalar that's convertible to an integer will\n               attempt to read records instead of lines, with the maximum\n               record size being the referenced integer.  So this:\n\n                   local $/ = \\32768; # or \\"32768", or \\$var_containing_32768\n                   open my $fh, "<", $myfile or die $!;\n                   local $_ = <$fh>;\n\n               will read a record of no more than 32768 bytes from FILE.  If\n               you're not reading from a record-oriented file (or your OS\n               doesn't have record-oriented files), then you'll likely get a\n               full chunk of data with every read.  If a record is larger than\n               the record size you've set, you'll get the record back in\n               pieces.  Trying to set the record size to zero or less will\n               cause reading in the (rest of the) whole file.
$|=       HANDLE->autoflush(EXPR)\n       $OUTPUT_AUTOFLUSH\n       $|      If set to nonzero, forces a flush right away and after every\n               write or print on the currently selected output channel.\n               Default is 0 (regardless of whether the channel is really\n               buffered by the system or not; $| tells you only whether you've\n               asked Perl explicitly to flush after each write).  STDOUT will\n               typically be line buffered if output is to the terminal and\n               block buffered otherwise.  Setting this variable is useful\n               primarily when you are outputting to a pipe or socket, such as\n               when you are running a Perl program under rrsshh and want to see\n               the output as it's happening.  This has no effect on input\n               buffering.  See "getc" in perlfunc for that.  See "select" in\n               perldoc on how to select the output channel.  See also\n               IO::Handle. (Mnemonic: when you want your pipes to be piping\n               hot.)
$OUTPUT_AUTO_FLUSH=
$,=       IO::Handle->output_field_separator EXPR\n       $OUTPUT_FIELD_SEPARATOR\n       $OFS\n       $,      The output field separator for the print operator.  If defined,\n               this value is printed between each of print's arguments.\n               Default is "undef".  (Mnemonic: what is printed when there is a\n               "," in your print statement.)
$OUTPUT_FIELD_SEPARATOR=       IO::Handle->output_field_separator EXPR\n       $OUTPUT_FIELD_SEPARATOR\n       $OFS\n       $,      The output field separator for the print operator.  If defined,\n               this value is printed between each of print's arguments.\n               Default is "undef".  (Mnemonic: what is printed when there is a\n               "," in your print statement.)
$OFS=       IO::Handle->output_field_separator EXPR\n       $OUTPUT_FIELD_SEPARATOR\n       $OFS\n       $,      The output field separator for the print operator.  If defined,\n               this value is printed between each of print's arguments.\n               Default is "undef".  (Mnemonic: what is printed when there is a\n               "," in your print statement.)
$\=       IO::Handle->output_record_separator EXPR\n       $OUTPUT_RECORD_SEPARATOR\n       $ORS\n       $\\      The output record separator for the print operator.  If\n               defined, this value is printed after the last of print's\n               arguments.  Default is "undef".  (Mnemonic: you set "$\\"\n               instead of adding "\\n" at the end of the print.  Also, it's\n               just like $/, but it's what you get "back" from Perl.)
$OUTPUT_RECORD_SEPARATOR=       IO::Handle->output_record_separator EXPR\n       $OUTPUT_RECORD_SEPARATOR\n       $ORS\n       $\\      The output record separator for the print operator.  If\n               defined, this value is printed after the last of print's\n               arguments.  Default is "undef".  (Mnemonic: you set "$\\"\n               instead of adding "\\n" at the end of the print.  Also, it's\n               just like $/, but it's what you get "back" from Perl.)
$ORS=       IO::Handle->output_record_separator EXPR\n       $OUTPUT_RECORD_SEPARATOR\n       $ORS\n       $\\      The output record separator for the print operator.  If\n               defined, this value is printed after the last of print's\n               arguments.  Default is "undef".  (Mnemonic: you set "$\\"\n               instead of adding "\\n" at the end of the print.  Also, it's\n               just like $/, but it's what you get "back" from Perl.)
$"=       $LIST_SEPARATOR\n       $"      This is like $, except that it applies to array and slice\n               values interpolated into a double-quoted string (or similar\n               interpreted string).  Default is a space.  (Mnemonic: obvious,\n               I think.)
$LIST_SEPARATOR=       $LIST_SEPARATOR\n       $"      This is like $, except that it applies to array and slice\n               values interpolated into a double-quoted string (or similar\n               interpreted string).  Default is a space.  (Mnemonic: obvious,\n               I think.)
$;=       $SUBSCRIPT_SEPARATOR\n       $SUBSEP\n       $;      The subscript separator for multidimensional array emulation.\n               If you refer to a hash element as\n\n                   $foo{$a,$b,$c}\n\n               it really means\n\n                   $foo{join($;, $a, $b, $c)}\n\n               But don't put\n\n                   @foo{$a,$b,$c}      # a slice--note the @\n\n               which means\n\n                   ($foo{$a},$foo{$b},$foo{$c})\n\n               Default is "\\034", the same as SUBSEP in aawwkk.  If your keys\n               contain binary data there might not be any safe value for $;.\n               (Mnemonic: comma (the syntactic subscript separator) is a semi-\n               semicolon.  Yeah, I know, it's pretty lame, but $, is already\n               taken for something more important.)\n\n               Consider using "real" multidimensional arrays as described in\n               perllol.
$SUBSCRIPT_SEPARATOR=       $SUBSCRIPT_SEPARATOR\n       $SUBSEP\n       $;      The subscript separator for multidimensional array emulation.\n               If you refer to a hash element as\n\n                   $foo{$a,$b,$c}\n\n               it really means\n\n                   $foo{join($;, $a, $b, $c)}\n\n               But don't put\n\n                   @foo{$a,$b,$c}      # a slice--note the @\n\n               which means\n\n                   ($foo{$a},$foo{$b},$foo{$c})\n\n               Default is "\\034", the same as SUBSEP in aawwkk.  If your keys\n               contain binary data there might not be any safe value for $;.\n               (Mnemonic: comma (the syntactic subscript separator) is a semi-\n               semicolon.  Yeah, I know, it's pretty lame, but $, is already\n               taken for something more important.)\n\n               Consider using "real" multidimensional arrays as described in\n               perllol.
$SUBSEP=       $SUBSCRIPT_SEPARATOR\n       $SUBSEP\n       $;      The subscript separator for multidimensional array emulation.\n               If you refer to a hash element as\n\n                   $foo{$a,$b,$c}\n\n               it really means\n\n                   $foo{join($;, $a, $b, $c)}\n\n               But don't put\n\n                   @foo{$a,$b,$c}      # a slice--note the @\n\n               which means\n\n                   ($foo{$a},$foo{$b},$foo{$c})\n\n               Default is "\\034", the same as SUBSEP in aawwkk.  If your keys\n               contain binary data there might not be any safe value for $;.\n               (Mnemonic: comma (the syntactic subscript separator) is a semi-\n               semicolon.  Yeah, I know, it's pretty lame, but $, is already\n               taken for something more important.)\n\n               Consider using "real" multidimensional arrays as described in\n               perllol.
$#=       $#      $# used to be a variable that could be used to format printed\n               numbers.  After a deprecation cycle, its magic was removed in\n               Perl 5.10 and using it now triggers a warning: "$# is no longer\n               supported".
$OFMT=
$%=       HANDLE->format_page_number(EXPR)\n       $FORMAT_PAGE_NUMBER\n       $%      The current page number of the currently selected output\n               channel.  Used with formats.  (Mnemonic: % is page number in\n               nnrrooffff.)
$FORMAT_PAGE_NUMBER=       HANDLE->format_page_number(EXPR)\n       $FORMAT_PAGE_NUMBER\n       $%      The current page number of the currently selected output\n               channel.  Used with formats.  (Mnemonic: % is page number in\n               nnrrooffff.)
$\==       HANDLE->format_lines_per_page(EXPR)\n       $FORMAT_LINES_PER_PAGE\n       $=      The current page length (printable lines) of the currently\n               selected output channel.  Default is 60.  Used with formats.\n               (Mnemonic: = has horizontal lines.)
$FORMAT_LINES_PER_PAGE=       HANDLE->format_lines_per_page(EXPR)\n       $FORMAT_LINES_PER_PAGE\n       $=      The current page length (printable lines) of the currently\n               selected output channel.  Default is 60.  Used with formats.\n               (Mnemonic: = has horizontal lines.)
$-=       HANDLE->format_lines_left(EXPR)\n       $FORMAT_LINES_LEFT\n       $-      The number of lines left on the page of the currently selected\n               output channel.  Used with formats.  (Mnemonic: lines_on_page -\n               lines_printed.)
$FORMAT_LINES_LEFT=       HANDLE->format_lines_left(EXPR)\n       $FORMAT_LINES_LEFT\n       $-      The number of lines left on the page of the currently selected\n               output channel.  Used with formats.  (Mnemonic: lines_on_page -\n               lines_printed.)
$~=       HANDLE->format_name(EXPR)\n       $FORMAT_NAME\n       $~      The name of the current report format for the currently\n               selected output channel.  Default is the name of the\n               filehandle.  (Mnemonic: brother to $^.)
$FORMAT_NAME=       HANDLE->format_name(EXPR)\n       $FORMAT_NAME\n       $~      The name of the current report format for the currently\n               selected output channel.  Default is the name of the\n               filehandle.  (Mnemonic: brother to $^.)
$^=       HANDLE->format_top_name(EXPR)\n       $FORMAT_TOP_NAME\n       $^      The name of the current top-of-page format for the currently\n               selected output channel.  Default is the name of the filehandle\n               with _TOP appended.  (Mnemonic: points to top of page.)
$FORMAT_TOP_NAME=       HANDLE->format_top_name(EXPR)\n       $FORMAT_TOP_NAME\n       $^      The name of the current top-of-page format for the currently\n               selected output channel.  Default is the name of the filehandle\n               with _TOP appended.  (Mnemonic: points to top of page.)
$\:=       IO::Handle->format_line_break_characters EXPR\n       $FORMAT_LINE_BREAK_CHARACTERS\n       $:      The current set of characters after which a string may be\n               broken to fill continuation fields (starting with ^) in a\n               format.  Default is " \\n-", to break on whitespace or hyphens.\n               (Mnemonic: a "colon" in poetry is a part of a line.)
$FORMAT_LINE_BREAK_CHARACTERS=       IO::Handle->format_line_break_characters EXPR\n       $FORMAT_LINE_BREAK_CHARACTERS\n       $:      The current set of characters after which a string may be\n               broken to fill continuation fields (starting with ^) in a\n               format.  Default is " \\n-", to break on whitespace or hyphens.\n               (Mnemonic: a "colon" in poetry is a part of a line.)
$?=       $CHILD_ERROR\n       $?      The status returned by the last pipe close, backtick ("``")\n               command, successful call to _w_a_i_t_(_) or _w_a_i_t_p_i_d_(_), or from the\n               _s_y_s_t_e_m_(_) operator.  This is just the 16-bit status word\n               returned by the traditional Unix _w_a_i_t_(_) system call (or else is\n               made up to look like it).  Thus, the exit value of the\n               subprocess is really ("$? >> 8"), and "$? & 127" gives which\n               signal, if any, the process died from, and "$? & 128" reports\n               whether there was a core dump.  (Mnemonic: similar to sshh and\n               kksshh.)\n\n               Additionally, if the "h_errno" variable is supported in C, its\n               value is returned via $? if any "gethost*()" function fails.
$CHILD_ERROR=       $CHILD_ERROR\n       $?      The status returned by the last pipe close, backtick ("``")\n               command, successful call to _w_a_i_t_(_) or _w_a_i_t_p_i_d_(_), or from the\n               _s_y_s_t_e_m_(_) operator.  This is just the 16-bit status word\n               returned by the traditional Unix _w_a_i_t_(_) system call (or else is\n               made up to look like it).  Thus, the exit value of the\n               subprocess is really ("$? >> 8"), and "$? & 127" gives which\n               signal, if any, the process died from, and "$? & 128" reports\n               whether there was a core dump.  (Mnemonic: similar to sshh and\n               kksshh.)\n\n               Additionally, if the "h_errno" variable is supported in C, its\n               value is returned via $? if any "gethost*()" function fails.
$^CHILD_ERROR_NATIVE=
$!=       $OS_ERROR\n       $ERRNO\n       $!      If used numerically, yields the current value of the C "errno"\n               variable, or in other words, if a system or library call fails,\n               it sets this variable.  This means that the value of $! is\n               meaningful only _i_m_m_e_d_i_a_t_e_l_y after a ffaaiilluurree:\n\n                   if (open my $fh, "<", $filename) {\n                       # Here $! is meaningless.\n                       ...\n                   } else {\n                       # ONLY here is $! meaningful.\n                       ...\n                       # Already here $! might be meaningless.\n                   }\n                   # Since here we might have either success or failure,\n                   # here $! is meaningless.
$ERRNO=       $OS_ERROR\n       $ERRNO\n       $!      If used numerically, yields the current value of the C "errno"\n               variable, or in other words, if a system or library call fails,\n               it sets this variable.  This means that the value of $! is\n               meaningful only _i_m_m_e_d_i_a_t_e_l_y after a ffaaiilluurree:\n\n                   if (open my $fh, "<", $filename) {\n                       # Here $! is meaningless.\n                       ...\n                   } else {\n                       # ONLY here is $! meaningful.\n                       ...\n                       # Already here $! might be meaningless.\n                   }\n                   # Since here we might have either success or failure,\n                   # here $! is meaningless.
$OS_ERROR=       $OS_ERROR\n       $ERRNO\n       $!      If used numerically, yields the current value of the C "errno"\n               variable, or in other words, if a system or library call fails,\n               it sets this variable.  This means that the value of $! is\n               meaningful only _i_m_m_e_d_i_a_t_e_l_y after a ffaaiilluurree:\n\n                   if (open my $fh, "<", $filename) {\n                       # Here $! is meaningless.\n                       ...\n                   } else {\n                       # ONLY here is $! meaningful.\n                       ...\n                       # Already here $! might be meaningless.\n                   }\n                   # Since here we might have either success or failure,\n                   # here $! is meaningless.
$@=       $EVAL_ERROR\n       $@      The Perl syntax error message from the last _e_v_a_l_(_) operator.\n               If $@ is the null string, the last _e_v_a_l_(_) parsed and executed\n               correctly (although the operations you invoked may have failed\n               in the normal fashion).  (Mnemonic: Where was the syntax error\n               "at"?)\n\n               Warning messages are not collected in this variable.  You can,\n               however, set up a routine to process warnings by setting\n               $SIG{__WARN__} as described below.
$EVAL_ERROR=       $EVAL_ERROR\n       $@      The Perl syntax error message from the last _e_v_a_l_(_) operator.\n               If $@ is the null string, the last _e_v_a_l_(_) parsed and executed\n               correctly (although the operations you invoked may have failed\n               in the normal fashion).  (Mnemonic: Where was the syntax error\n               "at"?)\n\n               Warning messages are not collected in this variable.  You can,\n               however, set up a routine to process warnings by setting\n               $SIG{__WARN__} as described below.
$$=       $PROCESS_ID\n       $PID\n       $$      The process number of the Perl running this script.  You should\n               consider this variable read-only, although it will be altered\n               across _f_o_r_k_(_) calls.  (Mnemonic: same as shells.)\n\n               Note for Linux users: on Linux, the C functions "getpid()" and\n               "getppid()" return different values from different threads. In\n               order to be portable, this behavior is not reflected by $$,\n               whose value remains consistent across threads. If you want to\n               call the underlying "getpid()", you may use the CPAN module\n               "Linux::Pid".
$PROCESS_ID=       $PROCESS_ID\n       $PID\n       $$      The process number of the Perl running this script.  You should\n               consider this variable read-only, although it will be altered\n               across _f_o_r_k_(_) calls.  (Mnemonic: same as shells.)\n\n               Note for Linux users: on Linux, the C functions "getpid()" and\n               "getppid()" return different values from different threads. In\n               order to be portable, this behavior is not reflected by $$,\n               whose value remains consistent across threads. If you want to\n               call the underlying "getpid()", you may use the CPAN module\n               "Linux::Pid".
$PID=       $PROCESS_ID\n       $PID\n       $$      The process number of the Perl running this script.  You should\n               consider this variable read-only, although it will be altered\n               across _f_o_r_k_(_) calls.  (Mnemonic: same as shells.)\n\n               Note for Linux users: on Linux, the C functions "getpid()" and\n               "getppid()" return different values from different threads. In\n               order to be portable, this behavior is not reflected by $$,\n               whose value remains consistent across threads. If you want to\n               call the underlying "getpid()", you may use the CPAN module\n               "Linux::Pid".
$<=       $REAL_USER_ID\n       $UID\n       $<      The real uid of this process.  (Mnemonic: it's the uid you came\n               _f_r_o_m, if you're running setuid.)  You can change both the real\n               uid and the effective uid at the same time by using\n               _P_O_S_I_X_:_:_s_e_t_u_i_d_(_).  Since changes to $< require a system call,\n               check $! after a change attempt to detect any possible errors.
$REAL_USER_ID=       $REAL_USER_ID\n       $UID\n       $<      The real uid of this process.  (Mnemonic: it's the uid you came\n               _f_r_o_m, if you're running setuid.)  You can change both the real\n               uid and the effective uid at the same time by using\n               _P_O_S_I_X_:_:_s_e_t_u_i_d_(_).  Since changes to $< require a system call,\n               check $! after a change attempt to detect any possible errors.
$UID=       $REAL_USER_ID\n       $UID\n       $<      The real uid of this process.  (Mnemonic: it's the uid you came\n               _f_r_o_m, if you're running setuid.)  You can change both the real\n               uid and the effective uid at the same time by using\n               _P_O_S_I_X_:_:_s_e_t_u_i_d_(_).  Since changes to $< require a system call,\n               check $! after a change attempt to detect any possible errors.
$>=       $EFFECTIVE_USER_ID\n       $EUID\n       $>      The effective uid of this process.  Example:\n\n                   $< = $>;            # set real to effective uid\n                   ($<,$>) = ($>,$<);  # swap real and effective uid\n\n               You can change both the effective uid and the real uid at the\n               same time by using _P_O_S_I_X_:_:_s_e_t_u_i_d_(_).  Changes to $> require a\n               check to $!  to detect any possible errors after an attempted\n               change.
$EFFECTIVE_USER_ID=       $EFFECTIVE_USER_ID\n       $EUID\n       $>      The effective uid of this process.  Example:\n\n                   $< = $>;            # set real to effective uid\n                   ($<,$>) = ($>,$<);  # swap real and effective uid\n\n               You can change both the effective uid and the real uid at the\n               same time by using _P_O_S_I_X_:_:_s_e_t_u_i_d_(_).  Changes to $> require a\n               check to $!  to detect any possible errors after an attempted\n               change.
$EUID=       $EFFECTIVE_USER_ID\n       $EUID\n       $>      The effective uid of this process.  Example:\n\n                   $< = $>;            # set real to effective uid\n                   ($<,$>) = ($>,$<);  # swap real and effective uid\n\n               You can change both the effective uid and the real uid at the\n               same time by using _P_O_S_I_X_:_:_s_e_t_u_i_d_(_).  Changes to $> require a\n               check to $!  to detect any possible errors after an attempted\n               change.
$(=       $REAL_GROUP_ID\n       $GID\n       $(      The real gid of this process.  If you are on a machine that\n               supports membership in multiple groups simultaneously, gives a\n               space separated list of groups you are in.  The first number is\n               the one returned by _g_e_t_g_i_d_(_), and the subsequent ones by\n               _g_e_t_g_r_o_u_p_s_(_), one of which may be the same as the first number.
$REAL_GROUP_ID=       $REAL_GROUP_ID\n       $GID\n       $(      The real gid of this process.  If you are on a machine that\n               supports membership in multiple groups simultaneously, gives a\n               space separated list of groups you are in.  The first number is\n               the one returned by _g_e_t_g_i_d_(_), and the subsequent ones by\n               _g_e_t_g_r_o_u_p_s_(_), one of which may be the same as the first number.
$GID=       $REAL_GROUP_ID\n       $GID\n       $(      The real gid of this process.  If you are on a machine that\n               supports membership in multiple groups simultaneously, gives a\n               space separated list of groups you are in.  The first number is\n               the one returned by _g_e_t_g_i_d_(_), and the subsequent ones by\n               _g_e_t_g_r_o_u_p_s_(_), one of which may be the same as the first number.
$)=       $EFFECTIVE_GROUP_ID\n       $EGID\n       $)      The effective gid of this process.  If you are on a machine\n               that supports membership in multiple groups simultaneously,\n               gives a space separated list of groups you are in.  The first\n               number is the one returned by _g_e_t_e_g_i_d_(_), and the subsequent\n               ones by _g_e_t_g_r_o_u_p_s_(_), one of which may be the same as the first\n               number.
$EFFECTIVE_GROUP_ID=       $EFFECTIVE_GROUP_ID\n       $EGID\n       $)      The effective gid of this process.  If you are on a machine\n               that supports membership in multiple groups simultaneously,\n               gives a space separated list of groups you are in.  The first\n               number is the one returned by _g_e_t_e_g_i_d_(_), and the subsequent\n               ones by _g_e_t_g_r_o_u_p_s_(_), one of which may be the same as the first\n               number.
$EGID=       $EFFECTIVE_GROUP_ID\n       $EGID\n       $)      The effective gid of this process.  If you are on a machine\n               that supports membership in multiple groups simultaneously,\n               gives a space separated list of groups you are in.  The first\n               number is the one returned by _g_e_t_e_g_i_d_(_), and the subsequent\n               ones by _g_e_t_g_r_o_u_p_s_(_), one of which may be the same as the first\n               number.
$0=       $<_d_i_g_i_t_s> ($1, $2, ...)\n               Contains the subpattern from the corresponding set of capturing\n               parentheses from the last successful pattern match, not\n               counting patterns matched in nested blocks that have been\n               exited already.  (Mnemonic: like \\digits.)  These variables are\n               all read-only and dynamically scoped to the current BLOCK.
$PROGRAM_NAME=       $PROGRAM_NAME\n       $0      Contains the name of the program being executed.
$[=       $[      The index of the first element in an array, and of the first\n               character in a substring.  Default is 0, but you could\n               theoretically set it to 1 to make Perl behave more like aawwkk (or\n               Fortran) when subscripting and when evaluating the _i_n_d_e_x_(_) and\n               _s_u_b_s_t_r_(_) functions.  (Mnemonic: [ begins subscripts.)\n\n               As of release 5 of Perl, assignment to $[ is treated as a\n               compiler directive, and cannot influence the behavior of any\n               other file.  (That's why you can only assign compile-time\n               constants to it.)  Its use is deprecated, and by default will\n               trigger a warning.
$]=       $]      The version + patchlevel / 1000 of the Perl interpreter.  This\n               variable can be used to determine whether the Perl interpreter\n               executing a script is in the right range of versions.\n               (Mnemonic: Is this version of perl in the right bracket?)\n               Example:\n\n                   warn "No checksumming!\\n" if $] < 3.019;\n\n               See also the documentation of "use VERSION" and "require\n               VERSION" for a convenient way to fail if the running Perl\n               interpreter is too old.
$^A=       $ACCUMULATOR\n       $^A     The current value of the _w_r_i_t_e_(_) accumulator for _f_o_r_m_a_t_(_)\n               lines.  A format contains _f_o_r_m_l_i_n_e_(_) calls that put their\n               result into $^A.  After calling its format, _w_r_i_t_e_(_) prints out\n               the contents of $^A and empties.  So you never really see the\n               contents of $^A unless you call _f_o_r_m_l_i_n_e_(_) yourself and then\n               look at it.  See perlform and "_f_o_r_m_l_i_n_e_(_)" in perlfunc.
$ACCUMULATOR=       $ACCUMULATOR\n       $^A     The current value of the _w_r_i_t_e_(_) accumulator for _f_o_r_m_a_t_(_)\n               lines.  A format contains _f_o_r_m_l_i_n_e_(_) calls that put their\n               result into $^A.  After calling its format, _w_r_i_t_e_(_) prints out\n               the contents of $^A and empties.  So you never really see the\n               contents of $^A unless you call _f_o_r_m_l_i_n_e_(_) yourself and then\n               look at it.  See perlform and "_f_o_r_m_l_i_n_e_(_)" in perlfunc.
$^C=       $COMPILING\n       $^C     The current value of the flag associated with the --cc switch.\n               Mainly of use with --MMOO==...... to allow code to alter its behavior\n               when being compiled, such as for example to AUTOLOAD at compile\n               time rather than normal, deferred loading.  Setting "$^C = 1"\n               is similar to calling "B::minus_c".
$COMPILING=       $COMPILING\n       $^C     The current value of the flag associated with the --cc switch.\n               Mainly of use with --MMOO==...... to allow code to alter its behavior\n               when being compiled, such as for example to AUTOLOAD at compile\n               time rather than normal, deferred loading.  Setting "$^C = 1"\n               is similar to calling "B::minus_c".
$^D=       $DEBUGGING\n       $^D     The current value of the debugging flags.  (Mnemonic: value of\n               --DD switch.) May be read or set. Like its command-line\n               equivalent, you can use numeric or symbolic values, eg "$^D =\n               10" or "$^D = "st"".
$DEBUGGING=       $DEBUGGING\n       $^D     The current value of the debugging flags.  (Mnemonic: value of\n               --DD switch.) May be read or set. Like its command-line\n               equivalent, you can use numeric or symbolic values, eg "$^D =\n               10" or "$^D = "st"".
$^E=       $EXTENDED_OS_ERROR\n       $^E     Error information specific to the current operating system.  At\n               the moment, this differs from $! under only VMS, OS/2, and\n               Win32 (and for MacPerl).  On all other platforms, $^E is always\n               just the same as $!.
$EXTENDED_OS_ERROR=       $EXTENDED_OS_ERROR\n       $^E     Error information specific to the current operating system.  At\n               the moment, this differs from $! under only VMS, OS/2, and\n               Win32 (and for MacPerl).  On all other platforms, $^E is always\n               just the same as $!.
$^ENCODING=
$^F=       $SYSTEM_FD_MAX\n       $^F     The maximum system file descriptor, ordinarily 2.  System file\n               descriptors are passed to _e_x_e_c_(_)ed processes, while higher file\n               descriptors are not.  Also, during an _o_p_e_n_(_), system file\n               descriptors are preserved even if the _o_p_e_n_(_) fails.  (Ordinary\n               file descriptors are closed before the _o_p_e_n_(_) is attempted.)\n               The close-on-exec status of a file descriptor will be decided\n               according to the value of $^F when the corresponding file,\n               pipe, or socket was opened, not the time of the _e_x_e_c_(_).
$SYSTEM_FD_MAX=       $SYSTEM_FD_MAX\n       $^F     The maximum system file descriptor, ordinarily 2.  System file\n               descriptors are passed to _e_x_e_c_(_)ed processes, while higher file\n               descriptors are not.  Also, during an _o_p_e_n_(_), system file\n               descriptors are preserved even if the _o_p_e_n_(_) fails.  (Ordinary\n               file descriptors are closed before the _o_p_e_n_(_) is attempted.)\n               The close-on-exec status of a file descriptor will be decided\n               according to the value of $^F when the corresponding file,\n               pipe, or socket was opened, not the time of the _e_x_e_c_(_).
$^H=       $^H     WARNING: This variable is strictly for internal use only.  Its\n               availability, behavior, and contents are subject to change\n               without notice.
$^I=       $INPLACE_EDIT\n       $^I     The current value of the inplace-edit extension.  Use "undef"\n               to disable inplace editing.  (Mnemonic: value of --ii switch.)
$INPLACE_EDIT=       $INPLACE_EDIT\n       $^I     The current value of the inplace-edit extension.  Use "undef"\n               to disable inplace editing.  (Mnemonic: value of --ii switch.)
$^L=       IO::Handle->format_formfeed EXPR\n       $FORMAT_FORMFEED\n       $^L     What formats output as a form feed.  Default is \\f.
$FORMAT_FORMFEED=       IO::Handle->format_formfeed EXPR\n       $FORMAT_FORMFEED\n       $^L     What formats output as a form feed.  Default is \\f.
$^M=       $^M     By default, running out of memory is an untrappable, fatal\n               error.  However, if suitably built, Perl can use the contents\n               of $^M as an emergency memory pool after _d_i_e_(_)ing.  Suppose\n               that your Perl were compiled with "-DPERL_EMERGENCY_SBRK" and\n               used Perl's malloc.  Then\n\n                   $^M = 'a' x (1 << 16);\n\n               would allocate a 64K buffer for use in an emergency.  See the\n               _I_N_S_T_A_L_L file in the Perl distribution for information on how to\n               add custom C compilation flags when compiling perl.  To\n               discourage casual use of this advanced feature, there is no\n               English long name for this variable.
$^N=       $LAST_SUBMATCH_RESULT\n       $^N     The text matched by the used group most-recently closed (i.e.\n               the group with the rightmost closing parenthesis) of the last\n               successful search pattern.  (Mnemonic: the (possibly) Nested\n               parenthesis that most recently closed.)\n\n               This is primarily used inside "(?{...})" blocks for examining\n               text recently matched. For example, to effectively capture text\n               to a variable (in addition to $1, $2, etc.), replace "(...)"\n               with\n\n                    (?:(...)(?{ $var = $^N }))\n\n               By setting and then using $var in this way relieves you from\n               having to worry about exactly which numbered set of parentheses\n               they are.
$^O=       $OSNAME\n       $^O     The name of the operating system under which this copy of Perl\n               was built, as determined during the configuration process. For\n               examples see "PLATFORMS" in perlport.
$OSNAME=       $OSNAME\n       $^O     The name of the operating system under which this copy of Perl\n               was built, as determined during the configuration process. For\n               examples see "PLATFORMS" in perlport.
$^OPEN=
$^P=       $PERLDB\n       $^P     The internal variable for debugging support.  The meanings of\n               the various bits are subject to change, but currently indicate:\n\n               0x01  Debug subroutine enter/exit.
$PERLDB=       $PERLDB\n       $^P     The internal variable for debugging support.  The meanings of\n               the various bits are subject to change, but currently indicate:\n\n               0x01  Debug subroutine enter/exit.
$^R=       $LAST_REGEXP_CODE_RESULT\n       $^R     The result of evaluation of the last successful "(?{ code })"\n               regular expression assertion (see perlre).  May be written to.
$LAST_REGEXP_CODE_RESULT=       $LAST_REGEXP_CODE_RESULT\n       $^R     The result of evaluation of the last successful "(?{ code })"\n               regular expression assertion (see perlre).  May be written to.
$^RE_DEBUG_FLAGS=
$^RE_TRIE_MAXBUF=
$^S=       $EXCEPTIONS_BEING_CAUGHT\n       $^S     Current state of the interpreter.
$EXCEPTIONS_BEING_CAUGHT=       $EXCEPTIONS_BEING_CAUGHT\n       $^S     Current state of the interpreter.
$^T=       $BASETIME\n       $^T     The time at which the program began running, in seconds since\n               the epoch (beginning of 1970).  The values returned by the --MM,\n               --AA, and --CC filetests are based on this value.
$BASETIME=       $BASETIME\n       $^T     The time at which the program began running, in seconds since\n               the epoch (beginning of 1970).  The values returned by the --MM,\n               --AA, and --CC filetests are based on this value.
$^TAINT=
$^UNICODE=
$^UTF8LOCALE=
$^V=       $PERL_VERSION\n       $^V     The revision, version, and subversion of the Perl interpreter,\n               represented as a "version" object.
$PERL_VERSION=       $PERL_VERSION\n       $^V     The revision, version, and subversion of the Perl interpreter,\n               represented as a "version" object.
$^W=       $WARNING\n       $^W     The current value of the warning switch, initially true if --ww\n               was used, false otherwise, but directly modifiable.  (Mnemonic:\n               related to the --ww switch.)  See also warnings.
$WARNING=       $WARNING\n       $^W     The current value of the warning switch, initially true if --ww\n               was used, false otherwise, but directly modifiable.  (Mnemonic:\n               related to the --ww switch.)  See also warnings.
$^WARNING_BITS=
$^WIDE_SYSTEM_CALLS=
$^X=       $EXECUTABLE_NAME\n       $^X     The name used to execute the current copy of Perl, from C's\n               "argv[0]" or (where supported) _/_p_r_o_c_/_s_e_l_f_/_e_x_e.
$EXECUTABLE_NAME=       $EXECUTABLE_NAME\n       $^X     The name used to execute the current copy of Perl, from C's\n               "argv[0]" or (where supported) _/_p_r_o_c_/_s_e_l_f_/_e_x_e.
$ARGV=       $ARGV   contains the name of the current file when reading from <>.
